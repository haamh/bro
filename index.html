<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Chat & Call</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding-bottom: 100px; /* Space for the fixed message form */
        }
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 Aspect Ratio */
            background-color: #333;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        .video-element {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.75rem;
        }
        .local-video-small {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 120px;
            height: 90px;
            border-radius: 0.5rem;
            border: 2px solid #fff;
            z-index: 10;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            border-radius: 0.75rem;
            z-index: 5;
        }
        #messageArea {
            max-height: 70vh; 
            overflow-y: auto;
        }
        #messageArea::-webkit-scrollbar { width: 8px; }
        #messageArea::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #messageArea::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #messageArea::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-100 to-pink-200 text-gray-800">

    <header class="bg-white shadow-md p-4 text-center rounded-b-xl sticky top-0 z-30">
        <h1 class="text-2xl sm:text-3xl font-extrabold text-purple-700">Secure Chat & Call</h1>
        <p class="text-xs sm:text-sm text-gray-600 mt-1">Encrypted messaging and calls for two.</p>
        <p id="userIdDisplay" class="text-xs text-gray-500 mt-2 hidden">
            Your User ID: <span class="font-mono bg-gray-100 px-2 py-1 rounded-md break-all"></span>
        </p>
    </header>

    <div class="p-4"> <!-- Main content wrapper that scrolls -->
        <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md my-4 hidden" role="alert">
            <strong class="font-bold">Error:</strong>
            <span class="block sm:inline ml-2"></span>
        </div>

        <div class="p-4 bg-white shadow-sm rounded-lg my-4 flex flex-col sm:flex-row items-center gap-3">
            <label for="sharedSecret" class="text-sm font-medium text-gray-700 whitespace-nowrap">Shared Secret Key:</label>
            <input id="sharedSecret" type="password" placeholder="Enter shared secret key" class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm w-full sm:w-auto"/>
            <button id="verifyKeyButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out">Verify Key & Connect</button>
            <div id="keyWarning" class="text-xs text-red-500 mt-2 sm:mt-0">
                <p><strong>Important:</strong> This key is NOT stored. You must re-enter it on refresh.</p>
                <p>Share this key securely with your chat partner OUTSIDE this app.</p>
                <button id="gotItButton" class="text-blue-600 hover:underline mt-1">Got it!</button>
            </div>
        </div>

        <div class="p-4 bg-white shadow-sm rounded-lg my-4 flex flex-col gap-3">
            <div class="flex flex-wrap items-center gap-2">
                <span class="text-sm font-medium text-gray-700">Connected Users (in this room):</span>
                <div id="connectedUsersList" class="flex-1 flex flex-wrap gap-2 text-sm text-gray-600">
                    <span class="text-gray-400 italic">None yet...</span>
                </div>
            </div>
            <div class="flex flex-wrap justify-center gap-2 sm:gap-4 mt-2">
                <button id="startAudioCallButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2" disabled>
                    <i class="fas fa-phone"></i> Audio Call
                </button>
                <button id="startVideoCallButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2" disabled>
                    <i class="fas fa-video"></i> Video Call
                </button>
                <button id="joinCallButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center gap-2">
                    <i class="fas fa-phone-volume"></i> Join Call
                </button>
                <button id="hangUpButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center gap-2">
                    <i class="fas fa-phone-slash"></i> Hang Up
                </button>
            </div>
        </div>

        <!-- Call and Chat Area Container -->
        <div class="relative min-h-[50vh]">
            <div id="videoCallArea" class="absolute inset-0 p-4 hidden flex-col items-center justify-center bg-gray-800 rounded-lg z-10">
                <div class="video-container w-full max-w-md">
                    <video id="remoteVideo" autoplay playsinline class="video-element"></video>
                    <div id="remoteVideoOverlay" class="video-overlay hidden">
                        <i id="remoteMicStatus" class="fas fa-microphone-slash mr-2"></i>
                        <i id="remoteCamStatus" class="fas fa-video-slash"></i>
                    </div>
                    <video id="localVideo" autoplay playsinline muted class="local-video-small"></video>
                </div>
                <p id="callStatus" class="text-white mt-2 text-lg"></p>
                <div class="flex flex-wrap justify-center gap-2 sm:gap-3 mt-4">
                    <button id="toggleMicButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-microphone"></i> <span class="hidden sm:inline">Mic</span>
                    </button>
                    <button id="toggleVideoButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-video"></i> <span class="hidden sm:inline">Video</span>
                    </button>
                    <button id="switchCamButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-camera-rotate"></i> <span class="hidden sm:inline">Switch</span>
                    </button>
                    <button id="toggleViewButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>
                    </button>
                </div>
            </div>

            <main id="messageArea" class="absolute inset-0 p-4 space-y-4">
                <!-- Messages will be rendered here by JS -->
                <div id="initialMessage" class="flex justify-center items-center h-full text-gray-500 text-base sm:text-lg italic text-center px-4">
                    <p>Start a secure conversation by entering a shared secret key and sending a message!</p>
                </div>
            </main>
        </div>
    </div>

    <form id="messageForm" class="bg-white p-3 sm:p-4 shadow-lg rounded-t-xl flex items-center space-x-2 sm:space-x-3 fixed bottom-0 left-0 right-0 w-full z-20">
        <input id="messageInput" type="text" placeholder="Type your message..." class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm sm:text-base" disabled />
        <label for="mediaInput" class="cursor-pointer bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-3 rounded-lg shadow-sm transition duration-300 ease-in-out">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                <path fill-rule="evenodd" d="M1.5 6a2.25 2.25 0 0 1 2.25-2.25h16.5A2.25 2.25 0 0 1 22.5 6v12a2.25 2.25 0 0 1-2.25 2.25H3.75A2.25 2.25 0 0 1 1.5 18V6ZM3 16.06V18c0 .414.336.75.75.75h16.5a.75.75 0 0 0 .75-.75v-1.94l-2.432-2.432a1.125 1.125 0 0 0-1.588 0L9.407 17.11c-.095.095-.22.14-.345.14-.125 0-.25-.045-.345-.14l-4.16-4.16a1.125 1.125 0 0 0-1.588 0L3 16.06ZM15.75 9.75a.75.75 0 0 1 .75-.75h.008a.75.75 0 0 1 .75.75v.008a.75.75 0 0 1-.75.75h-.008a.75.75 0 0 1-.75-.75V9.75Z" clip-rule="evenodd" />
            </svg>
            <input type="file" id="mediaInput" class="hidden" accept="image/*,video/*,audio/*">
        </label>
        <button id="sendButton" type="submit" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-5 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed text-sm sm:text-base" disabled>
            Send
        </button>
    </form>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, onSnapshot, serverTimestamp, query, setDoc, deleteDoc, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js";

        // Firebase app instances and config - module-scoped
        let app;
        let db;
        let auth;
        let firebaseConfig; // Will be assigned in window.onload

        // Application state variables
        let userId = null;
        let derivedKey = null;
        let messages = [];
        let peerConnection = null;
        let localStream = null;
        let callRoomId = null;
        let presenceInterval = null;
        let currentCameraDeviceId = null;
        let isVideoActive = true;
        let isAudioActive = true;
        let currentCallType = 'video'; // Default call type
        let callStateUnsubscribe = null; // To manage Firestore listener for call state

        // WebRTC configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ],
        };

        // DOM Element references
        const userIdDisplay = document.getElementById('userIdDisplay');
        const userIdSpan = userIdDisplay.querySelector('span');
        const errorMessageDiv = document.getElementById('errorMessage');
        const errorMessageSpan = errorMessageDiv.querySelector('span');
        const sharedSecretInput = document.getElementById('sharedSecret');
        const verifyKeyButton = document.getElementById('verifyKeyButton');
        const keyWarningDiv = document.getElementById('keyWarning');
        const gotItButton = document.getElementById('gotItButton');
        const messageArea = document.getElementById('messageArea');
        const initialMessageDiv = document.getElementById('initialMessage');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const mediaInput = document.getElementById('mediaInput');
        const connectedUsersList = document.getElementById('connectedUsersList');
        const startAudioCallButton = document.getElementById('startAudioCallButton');
        const startVideoCallButton = document.getElementById('startVideoCallButton');
        const joinCallButton = document.getElementById('joinCallButton');
        const hangUpButton = document.getElementById('hangUpButton');
        const videoCallArea = document.getElementById('videoCallArea');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const callStatus = document.getElementById('callStatus');
        const toggleMicButton = document.getElementById('toggleMicButton');
        const toggleVideoButton = document.getElementById('toggleVideoButton');
        const switchCamButton = document.getElementById('switchCamButton');
        const toggleViewButton = document.getElementById('toggleViewButton');
        const remoteVideoOverlay = document.getElementById('remoteVideoOverlay');
        const remoteMicStatus = document.getElementById('remoteMicStatus');
        const remoteCamStatus = document.getElementById('remoteCamStatus');

        // Helper functions for Base64 conversion
        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return btoa(binary);
        };
        const base64ToArrayBuffer = (base64) => {
            const binary_string = atob(base64);
            const bytes = new Uint8Array(binary_string.length);
            for (let i = 0; i < binary_string.length; i++) bytes[i] = binary_string.charCodeAt(i);
            return bytes.buffer;
        };

        // UI Helper: Show/Hide Error Messages
        const showErrorMessage = (message) => {
            errorMessageSpan.textContent = message;
            errorMessageDiv.classList.remove('hidden');
            setTimeout(() => {
                if (errorMessageSpan.textContent === message) hideErrorMessage();
            }, 5000);
        };
        const hideErrorMessage = () => {
            errorMessageDiv.classList.add('hidden');
            errorMessageSpan.textContent = '';
        };
        
        // Path construction helpers using module-scoped firebaseConfig
        const getArtifactsBasePath = () => {
            if (!firebaseConfig || !firebaseConfig.projectId) {
                console.error("Firebase config not ready for path construction."); return null; 
            }
            return `artifacts/${firebaseConfig.projectId}/public/data`;
        };
        const getMessagesColPath = () => { const basePath = getArtifactsBasePath(); return basePath ? `${basePath}/chat_messages` : null; };
        const getPresenceColPath = () => { const basePath = getArtifactsBasePath(); return basePath ? `${basePath}/presence` : null; };
        const getPresenceDocPath = (currentUserId) => { const basePath = getArtifactsBasePath(); return basePath && currentUserId ? `${basePath}/presence/${currentUserId}` : null; };
        const getCallDocPath = (currentCallRoomId) => { const basePath = getArtifactsBasePath(); return basePath && currentCallRoomId ? `${basePath}/calls/${currentCallRoomId}` : null; };
        const getCallCandidatesColPath = (currentCallRoomId) => { const callDocP = getCallDocPath(currentCallRoomId); return callDocP ? `${callDocP}/candidates` : null; };

        // Cryptography: Derive Key, Encrypt, Decrypt
        const deriveEncryptionKey = async (secret) => {
            if (!secret) {
                derivedKey = null; callRoomId = null;
                messageInput.disabled = true; sendButton.disabled = true;
                startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
                joinCallButton.classList.add('hidden');
                stopPresenceUpdates(); return;
            }
            try {
                const enc = new TextEncoder();
                const salt = enc.encode('secure-chat-salt'); 
                const keyMaterial = await window.crypto.subtle.importKey('raw', enc.encode(secret), { name: 'PBKDF2' }, false, ['deriveKey']);
                const derived = await window.crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
                derivedKey = derived;
                const keyHashBuffer = await crypto.subtle.digest('SHA-256', enc.encode(secret));
                callRoomId = arrayBufferToBase64(keyHashBuffer).replace(/[^a-zA-Z0-9]/g, '');
                hideErrorMessage();
                messageInput.disabled = false; sendButton.disabled = false;
                autoDecryptMessages();
                initializeCallListeners(); 
                startPresenceUpdates();
            } catch (error) {
                console.error("Error deriving key:", error);
                showErrorMessage("Failed to derive encryption key. Check secret or console.");
                derivedKey = null; callRoomId = null;
                messageInput.disabled = true; sendButton.disabled = true;
                startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
                joinCallButton.classList.add('hidden');
                stopPresenceUpdates();
            }
        };
        const autoDecryptMessages = async () => {
            if (!derivedKey) return;
            const newMessages = await Promise.all(messages.map(async (msg) => {
                const contentToDecrypt = msg.type === 'media' ? msg.encryptedContent : msg.encryptedText;
                if (contentToDecrypt && msg.iv && !msg.isDecrypted) {
                    try {
                        const decryptedContent = await decryptMessage(contentToDecrypt, msg.iv);
                        return { ...msg, decryptedText: decryptedContent, isDecrypted: true, decryptionError: null };
                    } catch (error) {
                        return { ...msg, decryptedText: null, isDecrypted: false, decryptionError: error.message };
                    }
                }
                return msg;
            }));
            messages = newMessages;
            renderMessages();
        };
        const encryptMessage = async (text) => {
            if (!derivedKey) { showErrorMessage("Encryption key not ready."); throw new Error("Encryption key not ready."); }
            try {
                const enc = new TextEncoder(); const encoded = enc.encode(text);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const ciphertext = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, derivedKey, encoded);
                return { encryptedText: arrayBufferToBase64(ciphertext), iv: arrayBufferToBase64(iv) };
            } catch (error) { console.error("Encryption failed:", error); showErrorMessage("Failed to encrypt message."); throw error; }
        };
        const decryptMessage = async (encryptedData, ivBase64) => {
            if (!derivedKey) { showErrorMessage("Decryption key not ready."); throw new Error("Decryption key not ready."); }
            try {
                const ciphertext = base64ToArrayBuffer(encryptedData); const iv = base64ToArrayBuffer(ivBase64);
                const decrypted = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv }, derivedKey, ciphertext);
                return new TextDecoder().decode(decrypted);
            } catch (error) { console.error("Decryption failed:", error); throw new Error("Decryption failed. Incorrect key or corrupted message."); }
        };
        
        // UI: Render Messages
        const renderMessages = () => {
            messageArea.innerHTML = ''; 
            if (messages.length === 0) {
                initialMessageDiv.classList.remove('hidden'); messageArea.appendChild(initialMessageDiv); return;
            } else {
                initialMessageDiv.classList.add('hidden');
            }
            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${msg.senderId === userId ? 'justify-end' : 'justify-start'}`;
                const contentDiv = document.createElement('div');
                contentDiv.className = `max-w-[80%] p-3 rounded-xl shadow-lg flex flex-col ${msg.senderId === userId ? 'bg-purple-500 text-white rounded-br-none' : 'bg-white text-gray-800 rounded-bl-none'}`;
                const senderSpan = document.createElement('span');
                senderSpan.className = 'text-xs opacity-80 mb-1';
                senderSpan.textContent = msg.senderId === userId ? 'You' : `User: ${msg.senderId.substring(0, 8)}...`;
                contentDiv.appendChild(senderSpan);

                if (msg.type === 'media' && msg.encryptedContent && msg.iv) {
                    if (msg.isDecrypted && msg.decryptedText) {
                        let mediaElement;
                        if (msg.mediaType === 'image') { mediaElement = document.createElement('img'); mediaElement.src = msg.decryptedText; }
                        else if (msg.mediaType === 'video') { mediaElement = document.createElement('video'); mediaElement.src = msg.decryptedText; mediaElement.controls = true; mediaElement.autoplay = true; }
                        else if (msg.mediaType === 'audio') { mediaElement = document.createElement('audio'); mediaElement.src = msg.decryptedText; mediaElement.controls = true; }
                        if (mediaElement) { mediaElement.className = 'max-w-full h-auto rounded-md'; contentDiv.appendChild(mediaElement); }
                    } else {
                        const encryptedP = document.createElement('p'); encryptedP.className = 'text-sm italic text-gray-400 break-words';
                        encryptedP.textContent = `Encrypted ${msg.mediaType} (${msg.fileName || 'unknown'})...`; contentDiv.appendChild(encryptedP);
                        if (msg.decryptionError) { const errorP = document.createElement('p'); errorP.className = 'text-xs text-red-300 mt-1'; errorP.textContent = `Error: ${msg.decryptionError}`; contentDiv.appendChild(errorP); }
                    }
                } else if (msg.encryptedText && msg.iv) {
                    if (msg.isDecrypted && msg.decryptedText) { const decryptedP = document.createElement('p'); decryptedP.className = 'text-sm break-words'; decryptedP.textContent = msg.decryptedText; contentDiv.appendChild(decryptedP); }
                    else {
                        const encryptedP = document.createElement('p'); encryptedP.className = 'text-sm italic text-gray-400 break-words';
                        encryptedP.textContent = `Encrypted: ${msg.encryptedText.substring(0,30)}...`; contentDiv.appendChild(encryptedP);
                        if (msg.decryptionError) { const errorP = document.createElement('p'); errorP.className = 'text-xs text-red-300 mt-1'; errorP.textContent = `Error: ${msg.decryptionError}`; contentDiv.appendChild(errorP); }
                    }
                }
                const timestampSpan = document.createElement('span'); timestampSpan.className = 'text-xs opacity-75 mt-1 block text-right';
                if (msg.timestamp?.toDate) timestampSpan.textContent = msg.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                else if (msg.timestamp) timestampSpan.textContent = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                contentDiv.appendChild(timestampSpan); messageDiv.appendChild(contentDiv); messageArea.appendChild(messageDiv);
            });
            messageArea.scrollTop = messageArea.scrollHeight;
        };

        // Firebase: Initialization & Listeners
        window.onload = async () => {
            try {
                firebaseConfig = { 
                    apiKey: "AIzaSyCPmT3kxQm4nqovB1eB5tWON2GCStcSzmg", 
                    authDomain: "sybau-2b8ae.firebaseapp.com",
                    projectId: "sybau-2b8ae",
                    storageBucket: "sybau-2b8ae.appspot.com", 
                    messagingSenderId: "973974019830",      
                    appId: "1:973974019830:web:2dfc448a43178aea6116d7" 
                };
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) { userId = user.uid; } 
                    else { 
                        try {
                            await signInAnonymously(auth);
                        } catch (err) {
                             console.error("Anonymous sign-in failed:", err); showErrorMessage("Authentication failed. Please refresh.");
                        }
                    }
                    
                    if (userId) {
                        userIdSpan.textContent = userId; userIdDisplay.classList.remove('hidden');
                        const messagesPath = getMessagesColPath();
                        if (messagesPath) {
                            onSnapshot(query(collection(db, messagesPath)), (snapshot) => {
                                const fetched = snapshot.docs.map(d => ({ id: d.id, ...d.data(), decryptedText: null, isDecrypted: false, decryptionError: null }));
                                fetched.sort((a, b) => (a.timestamp?.toDate()||0) - (b.timestamp?.toDate()||0));
                                messages = fetched; renderMessages(); autoDecryptMessages();
                            }, (error) => { console.error("Msg fetch error:", error); showErrorMessage("Msg fetch failed."); });
                        } else {
                            console.error("Messages collection path could not be determined.");
                        }
                        const presencePath = getPresenceColPath();
                        if (presencePath) {
                            onSnapshot(query(collection(db, presencePath)), (snapshot) => {
                                if (!callRoomId) return;
                                const now = Date.now();
                                const activeUsers = snapshot.docs.filter(d => d.data().lastSeen && (now - d.data().lastSeen.toDate().getTime() < 30000) && d.data().roomId === callRoomId).map(d => d.id);
                                connectedUsersList.innerHTML = '';
                                if (activeUsers.length === 0) {
                                    connectedUsersList.innerHTML = '<span class="text-gray-400 italic">None yet...</span>';
                                    startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
                                } else {
                                    activeUsers.forEach(id => { 
                                        const userSpan = document.createElement('span');
                                        userSpan.className = `bg-purple-200 text-purple-800 px-2 py-1 rounded-full text-xs ${id === userId ? 'font-bold' : ''}`;
                                        userSpan.textContent = id === userId ? 'You' : `User: ${id.substring(0, 8)}...`;
                                        connectedUsersList.appendChild(userSpan);
                                    });
                                    const otherUsersPresent = activeUsers.some(id => id !== userId);
                                    startAudioCallButton.disabled = !otherUsersPresent; startVideoCallButton.disabled = !otherUsersPresent;
                                }
                            }, (error) => { console.error("Presence error:", error); });
                        } else {
                            console.error("Presence collection path could not be determined.");
                        }
                    }
                });
            } catch (error) { console.error("Firebase init error:", error); showErrorMessage("App init failed. Check config."); }
        };
        
        function initializeCallListeners() {
            if (callStateUnsubscribe) callStateUnsubscribe();
            if (!callRoomId || !db) { console.warn("CallRoomId or DB not ready for call listeners."); return; }

            const callDocP = getCallDocPath(callRoomId);
            if (!callDocP) { console.error("Could not get call document path for listener."); return; }
            const callStateRef = doc(db, callDocP);

            callStateUnsubscribe = onSnapshot(callStateRef, async (docSnap) => {
                if (!docSnap.exists()) {
                    if (peerConnection) endCall(false);
                    callStatus.textContent = 'Call has ended.';
                    startAudioCallButton.classList.remove('hidden'); startVideoCallButton.classList.remove('hidden');
                    joinCallButton.classList.add('hidden'); hangUpButton.classList.add('hidden');
                    videoCallArea.classList.add('hidden'); messageArea.classList.remove('hidden');
                    toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>';
                    return;
                }
                const data = docSnap.data();
                currentCallType = data.callType || 'video';

                if ((data.status === 'ringing' || data.status === 'active') && data.callerId !== userId && !peerConnection) {
                    startAudioCallButton.classList.add('hidden'); startVideoCallButton.classList.add('hidden');
                    joinCallButton.classList.remove('hidden'); hangUpButton.classList.add('hidden');
                    callStatus.textContent = `${data.status === 'ringing' ? 'Incoming' : ''} ${currentCallType} call...`;
                    videoCallArea.classList.remove('hidden'); messageArea.classList.add('hidden');
                } else if (data.status === 'ended' && peerConnection) {
                    endCall(false); showErrorMessage("Call ended by other user.");
                }

                if (data.offer && data.offer.senderId !== userId && peerConnection && peerConnection.signalingState === 'stable') {
                    console.log('Received offer for a', currentCallType, 'call');
                    await setupPeerConnection(currentCallType); 
                    if (!peerConnection) return;

                    peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer)).then(async () => {
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        await setDoc(callStateRef, { answer: { sdp: answer.sdp, type: answer.type, senderId: userId }, status: 'active' }, { merge: true });
                        callStatus.textContent = 'Answering call...';
                        joinCallButton.classList.add('hidden'); hangUpButton.classList.remove('hidden');
                    }).catch(e => console.error("Error processing offer:", e));
                } else if (data.answer && data.answer.senderId !== userId && peerConnection && peerConnection.signalingState === 'have-local-offer') {
                    peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer))
                        .then(() => callStatus.textContent = 'Call connected!')
                        .catch(e => console.error("Error processing answer:", e));
                }
                if (data.trackStatus && data.trackStatus.senderId !== userId) { 
                    remoteMicStatus.classList.toggle('hidden', data.trackStatus.audio);
                    remoteCamStatus.classList.toggle('hidden', data.trackStatus.video);
                    remoteVideoOverlay.classList.toggle('hidden', data.trackStatus.audio && data.trackStatus.video);
                }
            }, (error) => { console.error("Call state listener error:", error); showErrorMessage("Call connection error."); });

            const candidatesPath = getCallCandidatesColPath(callRoomId);
            if (candidatesPath) {
                onSnapshot(query(collection(db, candidatesPath)), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added' && peerConnection) {
                            const candidateData = change.doc.data();
                            if (candidateData.senderId !== userId) {
                                try { await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData.candidate)); } 
                                catch (e) { console.error('Error adding ICE candidate:', e); }
                            }
                        }
                    });
                });
            } else {
                 console.error("Candidates collection path could not be determined for listener.");
            }
        }

        // Presence System
        const updatePresence = async () => {
            if (db && userId && callRoomId) {
                const path = getPresenceDocPath(userId);
                if (path) await setDoc(doc(db, path), { lastSeen: serverTimestamp(), roomId: callRoomId }, { merge: true });
            }
        };
        const startPresenceUpdates = () => { if (presenceInterval) clearInterval(presenceInterval); presenceInterval = setInterval(updatePresence, 10000); updatePresence(); };
        const stopPresenceUpdates = () => {
            if (presenceInterval) { clearInterval(presenceInterval); presenceInterval = null; }
            if (db && userId) {
                const path = getPresenceDocPath(userId);
                if (path) deleteDoc(doc(db, path)).catch(e => console.error("Error deleting presence:", e));
            }
        };

        // WebRTC Call Logic
        const setupPeerConnection = async (callType) => {
            console.log("setupPeerConnection called. Current peerConnection:", peerConnection);
            if (peerConnection) {
                console.log("Closing existing peer connection from setupPeerConnection start");
                try { peerConnection.close(); } catch(e) { console.warn("Error closing previous peer connection:", e); }
                peerConnection = null; 
            }

            try {
                console.log("Attempting to create new RTCPeerConnection");
                peerConnection = new RTCPeerConnection(rtcConfig); 
                console.log("New RTCPeerConnection object:", peerConnection);

                if (!peerConnection || typeof peerConnection.addTrack !== 'function') {
                    console.error("Failed to create a valid RTCPeerConnection object or it's missing addTrack.");
                    showErrorMessage("WebRTC setup failed: Connection object invalid.");
                    throw new Error("RTCPeerConnection instantiation failed"); 
                }
            } catch (e) {
                console.error("Error creating RTCPeerConnection:", e);
                showErrorMessage("WebRTC setup failed: " + e.message);
                if (peerConnection) { 
                     try { peerConnection.close(); } catch(closeError) { console.warn("Error closing peer connection after creation failure:", closeError); }
                     peerConnection = null;
                }
                throw e; 
            }
            
            currentCallType = callType;

            peerConnection.onicecandidate = async (event) => {
                if (event.candidate && callRoomId) {
                    const path = getCallCandidatesColPath(callRoomId);
                    if (path) await addDoc(collection(db, path), { senderId: userId, candidate: event.candidate.toJSON(), timestamp: serverTimestamp() });
                    else console.error("Cannot send ICE candidate, path is null.");
                }
            };
            peerConnection.ontrack = (event) => { if (remoteVideo.srcObject !== event.streams[0]) { remoteVideo.srcObject = event.streams[0]; callStatus.textContent = 'Connected!'; } };
            peerConnection.onnegotiationneeded = async () => {
                 if (!peerConnection || peerConnection.signalingState !== 'stable' || !callRoomId) return;
                try {
                    const offer = await peerConnection.createOffer(); await peerConnection.setLocalDescription(offer);
                    const path = getCallDocPath(callRoomId);
                    if (path) await setDoc(doc(db, path), { offer: { sdp: offer.sdp, type: offer.type, senderId: userId } }, { merge: true });
                    else console.error("Cannot send renegotiation offer, path is null.");
                } catch (e) { console.error('Renegotiation error:', e); }
            };

            try {
                console.log("Attempting getUserMedia for callType:", callType);
                const videoConstraint = callType === 'video' ? { width: { ideal: 640 }, height: { ideal: 480 } } : false;
                if (currentCameraDeviceId && callType === 'video' && videoConstraint) {
                    videoConstraint.deviceId = { exact: currentCameraDeviceId };
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraint, audio: true });
                localVideo.srcObject = localStream;
                
                console.log("getUserMedia successful. localStream:", localStream);
                console.log("Adding tracks to peerConnection:", peerConnection);

                if (!peerConnection) { 
                    console.error("CRITICAL: peerConnection is null before addTrack!");
                    throw new Error("peerConnection became null before adding tracks.");
                }

                localStream.getTracks().forEach(track => {
                    console.log("Adding track:", track, "to peerConnection:", peerConnection);
                    if (peerConnection && typeof peerConnection.addTrack === 'function') { 
                        peerConnection.addTrack(track, localStream);
                    } else {
                        console.error("Cannot add track, peerConnection is invalid or addTrack is not a function.");
                    }
                });
                console.log("Tracks added.");

                isVideoActive = callType === 'video' && localStream.getVideoTracks().some(t => t.enabled);
                isAudioActive = localStream.getAudioTracks().some(t => t.enabled);
                updateLocalTrackStatus();
                toggleVideoButton.style.display = callType === 'video' ? 'flex' : 'none';
                switchCamButton.style.display = callType === 'video' ? 'flex' : 'none';

            } catch (error) { 
                console.error('getUserMedia or track addition error:', error); 
                showErrorMessage('Cam/Mic access or track setup failed: ' + error.message);
                if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; }
                if (peerConnection) { try { peerConnection.close(); } catch(e) {console.warn("Error closing PC in catch:", e);} peerConnection = null; }
                throw error; 
            }
        };

        const updateLocalTrackStatus = async () => {
            if (db && callRoomId && userId) {
                const path = getCallDocPath(callRoomId);
                if (path) await setDoc(doc(db, path), { trackStatus: { senderId: userId, video: isVideoActive, audio: isAudioActive, timestamp: serverTimestamp() } }, { merge: true });
            }
        };

        const startCall = async (callType) => {
            if (!derivedKey || !callRoomId) { showErrorMessage("Verify secret key first."); return; }
            if (peerConnection?.connectionState !== 'closed' && peerConnection) { showErrorMessage("Call in progress."); return; }
            
            currentCallType = callType;
            videoCallArea.classList.remove('hidden'); messageArea.classList.add('hidden');
            startAudioCallButton.classList.add('hidden'); startVideoCallButton.classList.add('hidden');
            joinCallButton.classList.add('hidden'); hangUpButton.classList.remove('hidden');
            callStatus.textContent = `Starting ${callType} call...`;

            try {
                await setupPeerConnection(callType); 
                if (!peerConnection) { 
                    console.error("setupPeerConnection failed to establish a connection object in startCall.");
                    showErrorMessage('Failed to initialize call connection.');
                    endCall(true); 
                    return;
                }
                
                const offer = await peerConnection.createOffer(); 
                await peerConnection.setLocalDescription(offer);
                const path = getCallDocPath(callRoomId);
                if (path) {
                    await setDoc(doc(db, path), { offer: { sdp: offer.sdp, type: offer.type, senderId: userId }, status: 'ringing', callerId: userId, callType, timestamp: serverTimestamp() });
                    callStatus.textContent = 'Waiting for peer...';
                } else {
                     showErrorMessage('Failed to start call. Path error.'); endCall(true);
                }
            } catch (error) { // Catches errors from setupPeerConnection or offer creation
                console.error("Error during call initiation (setup or offer):", error);
                if (!videoCallArea.classList.contains('hidden')) { 
                    endCall(true); 
                }
            }
        };

        const joinExistingCall = async () => {
            if (!derivedKey || !callRoomId) { showErrorMessage("Verify secret key first."); return; }
            if (peerConnection?.connectionState !== 'closed' && peerConnection) { showErrorMessage("Already in call."); return; }
            
            const path = getCallDocPath(callRoomId);
            if (!path) { showErrorMessage("Call path error."); return; }
            
            try {
                const callDocSnap = await getDoc(doc(db, path));
                if (!callDocSnap.exists() || !callDocSnap.data().callType) { showErrorMessage("Call details missing."); return; }
                currentCallType = callDocSnap.data().callType;
                
                videoCallArea.classList.remove('hidden'); messageArea.classList.add('hidden');
                startAudioCallButton.classList.add('hidden'); startVideoCallButton.classList.add('hidden');
                joinCallButton.classList.add('hidden'); hangUpButton.classList.remove('hidden');
                callStatus.textContent = `Joining ${currentCallType} call...`;

                await setupPeerConnection(currentCallType);
                if (!peerConnection) {
                     console.error("setupPeerConnection failed for join call.");
                     showErrorMessage('Failed to initialize call connection for joining.');
                     endCall(true); 
                     return;
                }
                console.log("Peer connection set up for joining call.");
            } catch (error) {
                console.error("Error during join call (setup or getDoc):", error);
                if (!videoCallArea.classList.contains('hidden')) {
                    endCall(true);
                }
            }
        };
        const endCall = async (isInitiator = true) => {
            if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; localVideo.srcObject = null; }
            if (remoteVideo.srcObject) { remoteVideo.srcObject.getTracks().forEach(t => t.stop()); remoteVideo.srcObject = null; }
            if (peerConnection) { try {peerConnection.close();} catch(e){console.warn("Error closing PC in endCall:", e);} peerConnection = null; }
            
            if (isInitiator && db && callRoomId) {
                const path = getCallDocPath(callRoomId);
                if (path) await deleteDoc(doc(db, path)).catch(e => console.error("Call doc delete error:", e));
                const candidatesPath = getCallCandidatesColPath(callRoomId);
                if (candidatesPath) {
                    try { const snapshot = await getDocs(query(collection(db, candidatesPath))); snapshot.forEach(d => deleteDoc(d.ref)); } 
                    catch (e) { console.error("Candidates delete error:", e); }
                }
            }
            videoCallArea.classList.add('hidden'); messageArea.classList.remove('hidden');
            startAudioCallButton.classList.remove('hidden'); startVideoCallButton.classList.remove('hidden');
            joinCallButton.classList.add('hidden'); hangUpButton.classList.add('hidden');
            callStatus.textContent = '';
            isVideoActive = true; isAudioActive = true;
            toggleMicButton.innerHTML = '<i class="fas fa-microphone"></i> <span class="hidden sm:inline">Mic</span>';
            toggleVideoButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Video</span>';
            toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>';
        };

        // Call UI Controls
        const toggleLocalMic = () => { /* ... as before ... */ };
        const toggleLocalVideo = () => { /* ... as before ... */ };
        const switchCamera = async () => { /* ... as before ... */ };
        const toggleChatCallView = () => { /* ... as before ... */ };

        // Event Listeners Setup
        verifyKeyButton.addEventListener('click', () => { deriveEncryptionKey(sharedSecretInput.value); keyWarningDiv.classList.add('hidden'); });
        gotItButton.addEventListener('click', () => keyWarningDiv.classList.add('hidden'));
        document.getElementById('messageForm').addEventListener('submit', async (e) => {
            e.preventDefault(); const messageText = messageInput.value.trim();
            if (!messageText || !db || !userId || !derivedKey) { showErrorMessage("Enter secret & message."); return; }
            try {
                const { encryptedText, iv } = await encryptMessage(messageText);
                const messageData = { senderId: userId, encryptedText, iv, timestamp: serverTimestamp(), type: 'text' };
                const path = getMessagesColPath();
                if (path) await addDoc(collection(db, path), messageData);
                else console.error("Cannot send message, path is null.");
                messageInput.value = ''; hideErrorMessage();
            } catch (error) { console.error("Send message error:", error); }
        });
        mediaInput.addEventListener('change', async (e) => {
            const file = e.target.files[0]; if (!file) return;
            if (!db || !userId || !derivedKey) { showErrorMessage("Enter secret key for media."); return; }
            if (file.size > 2 * 1024 * 1024) { showErrorMessage("File > 2MB. Choose smaller."); return; }
            showErrorMessage("Uploading & encrypting media...");
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const { encryptedText, iv } = await encryptMessage(event.target.result);
                    const messageData = { senderId: userId, encryptedContent: encryptedText, iv, timestamp: serverTimestamp(), type: 'media', mediaType: file.type.split('/')[0], fileName: file.name };
                    const path = getMessagesColPath();
                    if (path) await addDoc(collection(db, path), messageData);
                    else console.error("Cannot send media, path is null.");
                    hideErrorMessage(); e.target.value = '';
                } catch (error) { console.error("Share media error:", error); showErrorMessage("Failed to share media. " + error.message); }
            };
            reader.readAsDataURL(file);
        });

        startAudioCallButton.addEventListener('click', () => startCall('audio'));
        startVideoCallButton.addEventListener('click', () => startCall('video'));
        joinCallButton.addEventListener('click', joinExistingCall);
        hangUpButton.addEventListener('click', () => endCall(true));
        toggleMicButton.addEventListener('click', toggleLocalMic);
        toggleVideoButton.addEventListener('click', toggleLocalVideo);
        switchCamButton.addEventListener('click', switchCamera);
        toggleViewButton.addEventListener('click', toggleChatCallView);
        window.addEventListener('beforeunload', () => { stopPresenceUpdates(); });

    </script>
</body>
</html>
