<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Chat & Call</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            /* Allow body to scroll */
            padding-bottom: 100px; /* Space for the fixed message form */
        }
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 Aspect Ratio */
            background-color: #333;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        .video-element {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.75rem;
        }
        .local-video-small {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 120px; /* Small size for local video */
            height: 90px; /* 4:3 aspect ratio */
            border-radius: 0.5rem;
            border: 2px solid #fff;
            z-index: 10;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        /* Overlay for muted status */
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            border-radius: 0.75rem;
            z-index: 5;
        }
        /* Ensure message area scrolls if its own content is too long,
           but it will also scroll with the body. */
        #messageArea {
            max-height: 70vh; /* Example max height before its own scrollbar appears */
            overflow-y: auto;
        }
        #messageArea::-webkit-scrollbar {
            width: 8px;
        }
        #messageArea::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #messageArea::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #messageArea::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

    </style>
</head>
<body class="bg-gradient-to-br from-purple-100 to-pink-200 text-gray-800">

    <header class="bg-white shadow-md p-4 text-center rounded-b-xl sticky top-0 z-30">
        <h1 class="text-2xl sm:text-3xl font-extrabold text-purple-700">Secure Chat & Call</h1>
        <p class="text-xs sm:text-sm text-gray-600 mt-1">Encrypted messaging and calls for two.</p>
        <p id="userIdDisplay" class="text-xs text-gray-500 mt-2 hidden">
            Your User ID: <span class="font-mono bg-gray-100 px-2 py-1 rounded-md break-all"></span>
        </p>
    </header>

    <div class="p-4"> <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md my-4 hidden" role="alert">
            <strong class="font-bold">Error:</strong>
            <span class="block sm:inline ml-2"></span>
        </div>

        <div class="p-4 bg-white shadow-sm rounded-lg my-4 flex flex-col sm:flex-row items-center gap-3">
            <label for="sharedSecret" class="text-sm font-medium text-gray-700 whitespace-nowrap">Shared Secret Key:</label>
            <input
                id="sharedSecret"
                type="password"
                placeholder="Enter shared secret key"
                class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm w-full sm:w-auto"
            />
            <button id="verifyKeyButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out">Verify Key & Connect</button>
            <div id="keyWarning" class="text-xs text-red-500 mt-2 sm:mt-0">
                <p><strong>Important:</strong> This key is NOT stored. You must re-enter it on refresh.</p>
                <p>Share this key securely with your chat partner OUTSIDE this app.</p>
                <button id="gotItButton" class="text-blue-600 hover:underline mt-1">Got it!</button>
            </div>
        </div>

        <div class="p-4 bg-white shadow-sm rounded-lg my-4 flex flex-col gap-3">
            <div class="flex flex-wrap items-center gap-2">
                <span class="text-sm font-medium text-gray-700">Connected Users (in this room):</span>
                <div id="connectedUsersList" class="flex-1 flex flex-wrap gap-2 text-sm text-gray-600">
                    <span class="text-gray-400 italic">None yet...</span>
                </div>
            </div>
            <div class="flex flex-wrap justify-center gap-2 sm:gap-4 mt-2">
                <button id="startAudioCallButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2" disabled>
                    <i class="fas fa-phone"></i> Audio Call
                </button>
                <button id="startVideoCallButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2" disabled>
                    <i class="fas fa-video"></i> Video Call
                </button>
                <button id="joinCallButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center gap-2">
                    <i class="fas fa-phone-volume"></i> Join Call
                </button>
                <button id="hangUpButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center gap-2">
                    <i class="fas fa-phone-slash"></i> Hang Up
                </button>
            </div>
        </div>

        <div class="relative min-h-[50vh]">
            <div id="videoCallArea" class="absolute inset-0 p-4 hidden flex-col items-center justify-center bg-gray-800 rounded-lg z-10">
                <div class="video-container w-full max-w-md">
                    <video id="remoteVideo" autoplay playsinline class="video-element"></video>
                    <div id="remoteVideoOverlay" class="video-overlay hidden">
                        <i id="remoteMicStatus" class="fas fa-microphone-slash mr-2"></i>
                        <i id="remoteCamStatus" class="fas fa-video-slash"></i>
                    </div>
                    <video id="localVideo" autoplay playsinline muted class="local-video-small"></video>
                </div>
                <p id="callStatus" class="text-white mt-2 text-lg"></p>
                <div class="flex flex-wrap justify-center gap-2 sm:gap-3 mt-4">
                    <button id="toggleMicButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-microphone"></i> <span class="hidden sm:inline">Mic</span>
                    </button>
                    <button id="toggleVideoButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-video"></i> <span class="hidden sm:inline">Video</span>
                    </button>
                    <button id="switchCamButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-camera-rotate"></i> <span class="hidden sm:inline">Switch</span>
                    </button>
                    <button id="toggleViewButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>
                    </button>
                </div>
            </div>

            <main id="messageArea" class="absolute inset-0 p-4 space-y-4">
                <div id="initialMessage" class="flex justify-center items-center h-full text-gray-500 text-base sm:text-lg italic text-center px-4">
                    <p>Start a secure conversation by entering a shared secret key and sending a message!</p>
                </div>
            </main>
        </div>
    </div>

    <form id="messageForm" class="bg-white p-3 sm:p-4 shadow-lg rounded-t-xl flex items-center space-x-2 sm:space-x-3 fixed bottom-0 left-0 right-0 w-full z-20">
        <input
            id="messageInput"
            type="text"
            placeholder="Type your message..."
            class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm sm:text-base"
            disabled
        />
        <label for="mediaInput" class="cursor-pointer bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-3 rounded-lg shadow-sm transition duration-300 ease-in-out">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                <path fill-rule="evenodd" d="M1.5 6a2.25 2.25 0 0 1 2.25-2.25h16.5A2.25 2.25 0 0 1 22.5 6v12a2.25 2.25 0 0 1-2.25 2.25H3.75A2.25 2.25 0 0 1 1.5 18V6ZM3 16.06V18c0 .414.336.75.75.75h16.5a.75.75 0 0 0 .75-.75v-1.94l-2.432-2.432a1.125 1.125 0 0 0-1.588 0L9.407 17.11c-.095.095-.22.14-.345.14-.125 0-.25-.045-.345-.14l-4.16-4.16a1.125 1.125 0 0 0-1.588 0L3 16.06ZM15.75 9.75a.75.75 0 0 1 .75-.75h.008a.75.75 0 0 1 .75.75v.008a.75.75 0 0 1-.75.75h-.008a.75.75 0 0 1-.75-.75V9.75Z" clip-rule="evenodd" />
            </svg>
            <input type="file" id="mediaInput" class="hidden" accept="image/*,video/*,audio/*">
        </label>
        <button
            id="sendButton"
            type="submit"
            class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-5 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed text-sm sm:text-base"
            disabled
        >
            Send
        </button>
    </form>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, onSnapshot, serverTimestamp, query, setDoc, deleteDoc, getDocs } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js"; // Added getDocs

        // Global variables for Firebase instances and state
        let app;
        let db;
        let auth;
        let userId = null;
        let derivedKey = null;
        let messages = []; // Array to store message data with decryption state
        let peerConnection = null;
        let localStream = null;
        let callRoomId = null; // Derived from sharedSecretKey
        let presenceInterval = null;
        let currentCameraDeviceId = null;
        let isVideoActive = true; // Track local video status
        let isAudioActive = true; // Track local audio status
        let currentCallType = 'video'; // To store 'audio' or 'video'

        // WebRTC STUN servers
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ],
        };

        // DOM Elements
        const userIdDisplay = document.getElementById('userIdDisplay');
        const userIdSpan = userIdDisplay.querySelector('span');
        const errorMessageDiv = document.getElementById('errorMessage');
        const errorMessageSpan = errorMessageDiv.querySelector('span');
        const sharedSecretInput = document.getElementById('sharedSecret');
        const verifyKeyButton = document.getElementById('verifyKeyButton');
        const keyWarningDiv = document.getElementById('keyWarning');
        const gotItButton = document.getElementById('gotItButton');
        const messageArea = document.getElementById('messageArea');
        const initialMessageDiv = document.getElementById('initialMessage');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const messageForm = document.getElementById('messageForm');
        const mediaInput = document.getElementById('mediaInput');
        const connectedUsersList = document.getElementById('connectedUsersList');
        
        const startAudioCallButton = document.getElementById('startAudioCallButton');
        const startVideoCallButton = document.getElementById('startVideoCallButton');
        const joinCallButton = document.getElementById('joinCallButton');
        const hangUpButton = document.getElementById('hangUpButton');
        
        const videoCallArea = document.getElementById('videoCallArea');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const callStatus = document.getElementById('callStatus');
        const toggleMicButton = document.getElementById('toggleMicButton');
        const toggleVideoButton = document.getElementById('toggleVideoButton');
        const switchCamButton = document.getElementById('switchCamButton');
        const toggleViewButton = document.getElementById('toggleViewButton');
        const remoteVideoOverlay = document.getElementById('remoteVideoOverlay');
        const remoteMicStatus = document.getElementById('remoteMicStatus');
        const remoteCamStatus = document.getElementById('remoteCamStatus');

        // Helper function to convert ArrayBuffer to Base64 string
        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        };

        // Helper function to convert Base64 string to ArrayBuffer
        const base64ToArrayBuffer = (base64) => {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        };

        // Function to display error messages
        const showErrorMessage = (message) => {
            errorMessageSpan.textContent = message;
            errorMessageDiv.classList.remove('hidden');
            // Auto-hide error after 5 seconds
            setTimeout(() => {
                 if (errorMessageSpan.textContent === message) { // Only hide if it's still the same message
                    hideErrorMessage();
                }
            }, 5000);
        };

        // Function to hide error messages
        const hideErrorMessage = () => {
            errorMessageDiv.classList.add('hidden');
            errorMessageSpan.textContent = '';
        };

        // Derive encryption key from shared secret
        const deriveEncryptionKey = async (secret) => {
            if (!secret) {
                derivedKey = null;
                callRoomId = null;
                messageInput.disabled = true;
                sendButton.disabled = true;
                startAudioCallButton.disabled = true;
                startVideoCallButton.disabled = true;
                joinCallButton.classList.add('hidden');
                stopPresenceUpdates();
                return;
            }
            try {
                const enc = new TextEncoder();
                const salt = enc.encode('secure-chat-salt'); 
                const keyMaterial = await window.crypto.subtle.importKey(
                    'raw', enc.encode(secret), { name: 'PBKDF2' }, false, ['deriveKey']
                );
                const derived = await window.crypto.subtle.deriveKey(
                    { name: 'PBKDF2', salt: salt, iterations: 100000, hash: 'SHA-256' },
                    keyMaterial, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']
                );
                derivedKey = derived;
                const keyHashBuffer = await crypto.subtle.digest('SHA-256', enc.encode(secret));
                callRoomId = arrayBufferToBase64(keyHashBuffer).replace(/[^a-zA-Z0-9]/g, '');
                hideErrorMessage();
                messageInput.disabled = false;
                sendButton.disabled = false;
                // Call buttons enabled/disabled based on presence later
                autoDecryptMessages();
                initializeCallListeners(); // Initialize call listeners once callRoomId is set
                startPresenceUpdates();
            } catch (error) {
                console.error("Error deriving key:", error);
                showErrorMessage("Failed to derive encryption key. Please check your shared secret.");
                derivedKey = null; callRoomId = null;
                messageInput.disabled = true; sendButton.disabled = true;
                startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
                joinCallButton.classList.add('hidden');
                stopPresenceUpdates();
            }
        };
        
        // Auto-decrypt all messages when key is available
        const autoDecryptMessages = async () => {
            if (!derivedKey) return;
            const newMessages = await Promise.all(messages.map(async (msg) => {
                const contentToDecrypt = msg.type === 'media' ? msg.encryptedContent : msg.encryptedText;
                if (contentToDecrypt && msg.iv && !msg.isDecrypted) {
                    try {
                        const decryptedContent = await decryptMessage(contentToDecrypt, msg.iv);
                        return { ...msg, decryptedText: decryptedContent, isDecrypted: true, decryptionError: null };
                    } catch (error) {
                        return { ...msg, decryptedText: null, isDecrypted: false, decryptionError: error.message };
                    }
                }
                return msg;
            }));
            messages = newMessages;
            renderMessages();
        };

        // Encrypt message
        const encryptMessage = async (text) => {
            if (!derivedKey) {
                showErrorMessage("Encryption key not ready. Please enter a shared secret.");
                throw new Error("Encryption key not ready.");
            }
            try {
                const enc = new TextEncoder();
                const encoded = enc.encode(text);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const ciphertext = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv }, derivedKey, encoded
                );
                return { encryptedText: arrayBufferToBase64(ciphertext), iv: arrayBufferToBase64(iv) };
            } catch (error) {
                console.error("Encryption failed:", error);
                showErrorMessage("Failed to encrypt message. Is your shared secret correct?");
                throw error;
            }
        };

        // Decrypt message
        const decryptMessage = async (encryptedData, ivBase64) => {
            if (!derivedKey) {
                showErrorMessage("Decryption key not ready. Please enter a shared secret.");
                throw new Error("Decryption key not ready.");
            }
            try {
                const ciphertext = base64ToArrayBuffer(encryptedData);
                const iv = base64ToArrayBuffer(ivBase64);
                const decrypted = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv }, derivedKey, ciphertext
                );
                const dec = new TextDecoder();
                return dec.decode(decrypted);
            } catch (error) {
                console.error("Decryption failed:", error);
                throw new Error("Decryption failed. Incorrect key or corrupted message.");
            }
        };
        
        // Render messages to the UI
        const renderMessages = () => {
            messageArea.innerHTML = ''; 
            if (messages.length === 0) {
                initialMessageDiv.classList.remove('hidden');
                messageArea.appendChild(initialMessageDiv);
                return;
            } else {
                initialMessageDiv.classList.add('hidden');
            }

            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${msg.senderId === userId ? 'justify-end' : 'justify-start'}`;
                const contentDiv = document.createElement('div');
                contentDiv.className = `max-w-[80%] p-3 rounded-xl shadow-lg flex flex-col ${
                    msg.senderId === userId ? 'bg-purple-500 text-white rounded-br-none' : 'bg-white text-gray-800 rounded-bl-none'
                }`;
                const senderSpan = document.createElement('span');
                senderSpan.className = 'text-xs opacity-80 mb-1';
                senderSpan.textContent = msg.senderId === userId ? 'You' : `User: ${msg.senderId.substring(0, 8)}...`;
                contentDiv.appendChild(senderSpan);

                if (msg.type === 'media' && msg.encryptedContent && msg.iv) {
                    if (msg.isDecrypted && msg.decryptedText) {
                        if (msg.mediaType === 'image') {
                            const imgElement = document.createElement('img');
                            imgElement.src = msg.decryptedText;
                            imgElement.className = 'max-w-full h-auto rounded-md';
                            contentDiv.appendChild(imgElement);
                        } else if (msg.mediaType === 'video') {
                            const videoElement = document.createElement('video');
                            videoElement.src = msg.decryptedText; videoElement.controls = true; videoElement.autoplay = true;
                            videoElement.className = 'max-w-full h-auto rounded-md';
                            contentDiv.appendChild(videoElement);
                        } else if (msg.mediaType === 'audio') {
                            const audioElement = document.createElement('audio');
                            audioElement.src = msg.decryptedText; audioElement.controls = true;
                            audioElement.className = 'max-w-full h-auto rounded-md';
                            contentDiv.appendChild(audioElement);
                        }
                    } else {
                        const encryptedP = document.createElement('p');
                        encryptedP.className = 'text-sm sm:text-base italic text-gray-400 break-words';
                        encryptedP.textContent = `Encrypted ${msg.mediaType} file (${msg.fileName || 'unknown'})...`;
                        contentDiv.appendChild(encryptedP);
                        if (msg.decryptionError) {
                            const errorP = document.createElement('p');
                            errorP.className = 'text-xs text-red-300 mt-1'; errorP.textContent = `Error: ${msg.decryptionError}`;
                            contentDiv.appendChild(errorP);
                        }
                    }
                } else if (msg.encryptedText && msg.iv) {
                    if (msg.isDecrypted && msg.decryptedText) {
                        const decryptedP = document.createElement('p');
                        decryptedP.className = 'text-sm sm:text-base break-words'; decryptedP.textContent = msg.decryptedText;
                        contentDiv.appendChild(decryptedP);
                    } else {
                        const encryptedP = document.createElement('p');
                        encryptedP.className = 'text-sm sm:text-base italic text-gray-400 break-words';
                        encryptedP.textContent = `Encrypted Message: ${msg.encryptedText ? msg.encryptedText.substring(0, 30) + '...' : 'N/A'}`;
                        contentDiv.appendChild(encryptedP);
                        if (msg.decryptionError) {
                            const errorP = document.createElement('p');
                            errorP.className = 'text-xs text-red-300 mt-1'; errorP.textContent = `Error: ${msg.decryptionError}`;
                            contentDiv.appendChild(errorP);
                        }
                    }
                }
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'text-xs opacity-75 mt-1 block text-right';
                if (msg.timestamp && msg.timestamp.toDate) {
                    timestampSpan.textContent = msg.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } else if (msg.timestamp) {
                    timestampSpan.textContent = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }
                contentDiv.appendChild(timestampSpan);
                messageDiv.appendChild(contentDiv);
                messageArea.appendChild(messageDiv);
            });
            messageArea.scrollTop = messageArea.scrollHeight;
        };

        // --- Firebase Initialization and Auth Listener ---
        window.onload = async () => {
            try {
                // MAKE SURE this firebaseConfig matches your project in Firebase Console
                const firebaseConfig = {
                    apiKey: "AIzaSyCPmT3kxQm4nqovB1eB5tWON2GCStcSzmg",
                    authDomain: "sybau-2b8ae.firebaseapp.com",
                    projectId: "sybau-2b8ae",
                    storageBucket: "sybau-2b8ae.appspot.com", // or .firebasestorage.app
                    messagingSenderId: "973974019830",
                    appId: "1:973974019830:web:2dfc448a43178aea6116d7"
                };
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        await signInAnonymously(auth).catch(err => {
                            console.error("Anonymous sign-in failed:", err);
                            showErrorMessage("Authentication failed. Please refresh.");
                        });
                    }
                    if (userId) { // Proceed only if userId is available
                        userIdSpan.textContent = userId;
                        userIdDisplay.classList.remove('hidden');

                        const messagesCollectionPath = `artifacts/${firebaseConfig.projectId}/public/data/chat_messages`;
                        const messagesQuery = query(collection(db, messagesCollectionPath));
                        onSnapshot(messagesQuery, (snapshot) => {
                            const fetchedMessages = snapshot.docs.map(doc => ({
                                id: doc.id, ...doc.data(), decryptedText: null, isDecrypted: false, decryptionError: null,
                            }));
                            fetchedMessages.sort((a, b) => (a.timestamp?.toDate() || 0) - (b.timestamp?.toDate() || 0));
                            messages = fetchedMessages; renderMessages(); autoDecryptMessages();
                        }, (error) => {
                            console.error("Error fetching messages:", error);
                            showErrorMessage("Failed to fetch messages. Check connection or Firestore setup.");
                        });

                        const presenceCollectionPath = `artifacts/${firebaseConfig.projectId}/public/data/presence`;
                        onSnapshot(query(collection(db, presenceCollectionPath)), (snapshot) => {
                            if (!callRoomId) return;
                            const now = Date.now();
                            const activeUsers = snapshot.docs.filter(doc => {
                                const data = doc.data();
                                return data.lastSeen && (now - data.lastSeen.toDate().getTime() < 30000) && data.roomId === callRoomId;
                            }).map(doc => doc.id);

                            connectedUsersList.innerHTML = '';
                            if (activeUsers.length === 0) {
                                connectedUsersList.innerHTML = '<span class="text-gray-400 italic">None yet...</span>';
                                startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
                            } else {
                                activeUsers.forEach(id => {
                                    const userSpan = document.createElement('span');
                                    userSpan.className = `bg-purple-200 text-purple-800 px-2 py-1 rounded-full text-xs ${id === userId ? 'font-bold' : ''}`;
                                    userSpan.textContent = id === userId ? 'You' : `User: ${id.substring(0, 8)}...`;
                                    connectedUsersList.appendChild(userSpan);
                                });
                                // Enable call buttons if there's at least one *other* user.
                                const otherUsersPresent = activeUsers.some(id => id !== userId);
                                startAudioCallButton.disabled = !otherUsersPresent;
                                startVideoCallButton.disabled = !otherUsersPresent;
                            }
                        }, (error) => {
                            console.error("Error listening to presence:", error);
                        });
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showErrorMessage("Failed to initialize the app. Please try again or check Firebase config.");
            }
        };
        
        let callStateUnsubscribe = null; // To store the unsubscribe function for call state listener

        function initializeCallListeners() {
            if (callStateUnsubscribe) {
                callStateUnsubscribe(); // Unsubscribe from previous listener if any
            }
            if (!callRoomId || !db) return;

            const callDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}`; // Use projectId from config
            const callStateRef = doc(db, callDocPath);

            callStateUnsubscribe = onSnapshot(callStateRef, (docSnap) => {
                if (!docSnap.exists()) { // Call document deleted (everyone hung up)
                    if (peerConnection) endCall(false); // false = not initiated by this user's hangup button
                    
                    callStatus.textContent = 'Call has ended.';
                    startAudioCallButton.classList.remove('hidden');
                    startVideoCallButton.classList.remove('hidden');
                    joinCallButton.classList.add('hidden');
                    hangUpButton.classList.add('hidden');
                    videoCallArea.classList.add('hidden');
                    messageArea.classList.remove('hidden');
                    toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>'; // Reset toggle button
                    return;
                }

                const data = docSnap.data();
                currentCallType = data.callType || 'video'; // Update current call type

                if (data.status === 'ringing' && data.callerId !== userId && !peerConnection) {
                    startAudioCallButton.classList.add('hidden');
                    startVideoCallButton.classList.add('hidden');
                    joinCallButton.classList.remove('hidden');
                    hangUpButton.classList.add('hidden');
                    callStatus.textContent = `Incoming ${currentCallType} call...`;
                    videoCallArea.classList.remove('hidden'); 
                    messageArea.classList.add('hidden');
                } else if (data.status === 'active' && data.callerId !== userId && !peerConnection) {
                    startAudioCallButton.classList.add('hidden');
                    startVideoCallButton.classList.add('hidden');
                    joinCallButton.classList.remove('hidden');
                    hangUpButton.classList.add('hidden');
                    callStatus.textContent = `${currentCallType} call active in room.`;
                    videoCallArea.classList.remove('hidden');
                    messageArea.classList.add('hidden');
                } else if (data.status === 'ended' && peerConnection) { // Call ended by other party while we are in call
                    endCall(false); // false = not initiated by this user's hangup button
                    showErrorMessage("Call ended by other user.");
                }


                if (data.offer && data.offer.senderId !== userId && peerConnection && peerConnection.signalingState === 'stable') {
                    console.log('Received offer:', data.offer.sdp);
                    peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer)).then(async () => {
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        await setDoc(callStateRef, { answer: { sdp: answer.sdp, type: answer.type, senderId: userId }, status: 'active' }, { merge: true });
                        callStatus.textContent = 'Answering call...';
                        joinCallButton.classList.add('hidden');
                        hangUpButton.classList.remove('hidden');
                    }).catch(e => console.error("Error processing offer:", e));
                } else if (data.answer && data.answer.senderId !== userId && peerConnection && peerConnection.signalingState === 'have-local-offer') {
                    console.log('Received answer:', data.answer.sdp);
                    peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer))
                        .then(() => callStatus.textContent = 'Call connected!')
                        .catch(e => console.error("Error processing answer:", e));
                }

                if (data.trackStatus && data.trackStatus.senderId !== userId) {
                    remoteMicStatus.classList.toggle('hidden', data.trackStatus.audio);
                    remoteCamStatus.classList.toggle('hidden', data.trackStatus.video);
                    remoteVideoOverlay.classList.toggle('hidden', data.trackStatus.audio && data.trackStatus.video);
                }
            }, (error) => {
                console.error("Error listening to call state:", error);
                showErrorMessage("Error with call connection.");
            });

            // Listen for ICE candidates
            const candidatesCollectionPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}/candidates`;
            const candidatesQuery = query(collection(db, candidatesCollectionPath));
            onSnapshot(candidatesQuery, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && peerConnection) {
                        const candidateData = change.doc.data();
                        if (candidateData.senderId !== userId) {
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData.candidate));
                            } catch (e) { console.error('Error adding received ICE candidate:', e); }
                        }
                    }
                });
            });
        }


        // --- Presence System ---
        const updatePresence = async () => {
            if (db && userId && callRoomId) {
                const presenceDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/presence/${userId}`;
                await setDoc(doc(db, presenceDocPath), {
                    lastSeen: serverTimestamp(), roomId: callRoomId,
                }, { merge: true });
            }
        };
        const startPresenceUpdates = () => {
            if (presenceInterval) clearInterval(presenceInterval);
            presenceInterval = setInterval(updatePresence, 10000);
            updatePresence();
        };
        const stopPresenceUpdates = () => {
            if (presenceInterval) { clearInterval(presenceInterval); presenceInterval = null; }
            if (db && userId) {
                const presenceDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/presence/${userId}`;
                deleteDoc(doc(db, presenceDocPath)).catch(e => console.error("Error deleting presence:", e));
            }
        };

        // --- WebRTC Call Functionality ---
        const setupPeerConnection = async (callType) => {
            if (peerConnection) peerConnection.close(); // Close existing connection
            peerConnection = new RTCPeerConnection(rtcConfig);
            currentCallType = callType; // Store the type of call being set up

            peerConnection.onicecandidate = async (event) => {
                if (event.candidate && callRoomId) {
                    const candidatesColPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}/candidates`;
                    await addDoc(collection(db, candidatesColPath), {
                        senderId: userId, candidate: event.candidate.toJSON(), timestamp: serverTimestamp(),
                    });
                }
            };
            peerConnection.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    callStatus.textContent = 'Connected!';
                }
            };
            peerConnection.onnegotiationneeded = async () => {
                 if (!peerConnection || peerConnection.signalingState !== 'stable' || !callRoomId) return;
                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    const callDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}`;
                    await setDoc(doc(db, callDocPath), { offer: { sdp: offer.sdp, type: offer.type, senderId: userId } }, { merge: true });
                } catch (e) { console.error('Renegotiation error:', e); }
            };

            try {
                const videoConstraint = callType === 'video' ? { width: { ideal: 640 }, height: { ideal: 480 } } : false;
                if (currentCameraDeviceId && callType === 'video') {
                    videoConstraint.deviceId = { exact: currentCameraDeviceId };
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraint, audio: true });
                localVideo.srcObject = localStream;
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
                isVideoActive = callType === 'video' && localStream.getVideoTracks().some(t => t.enabled);
                isAudioActive = localStream.getAudioTracks().some(t => t.enabled);
                updateLocalTrackStatus();
                toggleVideoButton.style.display = callType === 'video' ? 'flex' : 'none';
                switchCamButton.style.display = callType === 'video' ? 'flex' : 'none';

            } catch (error) {
                console.error('Error getting user media:', error);
                showErrorMessage('Failed to get camera/microphone access. Please allow permissions.');
                endCall(true); return;
            }
        };

        const updateLocalTrackStatus = async () => {
            if (db && callRoomId && userId) {
                const callDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}`;
                await setDoc(doc(db, callDocPath), {
                    trackStatus: { senderId: userId, video: isVideoActive, audio: isAudioActive, timestamp: serverTimestamp() }
                }, { merge: true });
            }
        };

        const startCall = async (callType) => { // callType: 'audio' or 'video'
            if (!derivedKey || !callRoomId) { showErrorMessage("Please verify your shared secret key first."); return; }
            if (peerConnection && peerConnection.connectionState !== 'closed') { showErrorMessage("Call already in progress."); return; }

            currentCallType = callType;
            videoCallArea.classList.remove('hidden');
            messageArea.classList.add('hidden');
            startAudioCallButton.classList.add('hidden');
            startVideoCallButton.classList.add('hidden');
            joinCallButton.classList.add('hidden');
            hangUpButton.classList.remove('hidden');
            callStatus.textContent = `Starting ${callType} call...`;
            
            await setupPeerConnection(callType);
            if (!peerConnection) return; // setupPeerConnection might have failed

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                const callDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}`;
                await setDoc(doc(db, callDocPath), {
                    offer: { sdp: offer.sdp, type: offer.type, senderId: userId },
                    status: 'ringing', callerId: userId, callType: callType, timestamp: serverTimestamp(),
                });
                callStatus.textContent = 'Waiting for peer...';
            } catch (error) {
                console.error('Error creating/sending offer:', error);
                showErrorMessage('Failed to start call.');
                endCall(true);
            }
        };

        const joinExistingCall = async () => {
            if (!derivedKey || !callRoomId) { showErrorMessage("Please verify your shared secret key first."); return; }
            if (peerConnection && peerConnection.connectionState !== 'closed') { showErrorMessage("Already in a call."); return; }

            // Fetch the current call type from Firestore before joining
            const callDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}`;
            const callDocSnap = await getDoc(doc(db, callDocPath));
            if (!callDocSnap.exists() || !callDocSnap.data().callType) {
                showErrorMessage("Call details not found or call type missing.");
                return;
            }
            currentCallType = callDocSnap.data().callType;

            videoCallArea.classList.remove('hidden');
            messageArea.classList.add('hidden');
            startAudioCallButton.classList.add('hidden');
            startVideoCallButton.classList.add('hidden');
            joinCallButton.classList.add('hidden');
            hangUpButton.classList.remove('hidden');
            callStatus.textContent = `Joining ${currentCallType} call...`;

            await setupPeerConnection(currentCallType); // Join with the correct call type
             if (!peerConnection) return;

            // The offer/answer logic is handled by onSnapshot for the callStateRef
            // We just need to ensure the peerConnection is ready to receive an offer
            // and the call status is updated if needed (though onSnapshot should handle this).
            // For joining, we typically wait for an offer from the existing participants (or if an offer is already there).
            // The onSnapshot for callRef will handle setRemoteDescription and createAnswer.
        };


        const endCall = async (isInitiator = true) => { // isInitiator helps decide if we delete the call doc
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null; localVideo.srcObject = null;
            }
            if (remoteVideo.srcObject) {
                remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                remoteVideo.srcObject = null;
            }
            if (peerConnection) {
                peerConnection.close(); peerConnection = null;
            }

            if (isInitiator && db && callRoomId) { // Only the person clicking hangup (or last one) deletes the call doc
                const callDocPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}`;
                await deleteDoc(doc(db, callDocPath)).catch(e => console.error("Error deleting call doc:", e));
                
                const candidatesColPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/calls/${callRoomId}/candidates`;
                const q = query(collection(db, candidatesColPath));
                try {
                    const snapshot = await getDocs(q); // getDocs is now imported
                    snapshot.forEach(doc => deleteDoc(doc.ref));
                } catch (e) { console.error("Error deleting candidates:", e); }
            }
            
            videoCallArea.classList.add('hidden');
            messageArea.classList.remove('hidden');
            startAudioCallButton.classList.remove('hidden');
            startVideoCallButton.classList.remove('hidden');
            joinCallButton.classList.add('hidden');
            hangUpButton.classList.add('hidden');
            callStatus.textContent = '';
            // Do not hide global error message here, let it auto-hide or be replaced.
            isVideoActive = true; isAudioActive = true;
            toggleMicButton.innerHTML = '<i class="fas fa-microphone"></i> <span class="hidden sm:inline">Mic</span>';
            toggleVideoButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Video</span>';
            toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>'; // Reset toggle button
        };

        const toggleLocalMic = () => {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled; isAudioActive = audioTrack.enabled;
                    toggleMicButton.innerHTML = audioTrack.enabled ? '<i class="fas fa-microphone"></i> <span class="hidden sm:inline">Mic</span>' : '<i class="fas fa-microphone-slash"></i> <span class="hidden sm:inline">Mic</span>';
                    updateLocalTrackStatus();
                }
            }
        };
        const toggleLocalVideo = () => {
            if (localStream && currentCallType === 'video') { // Only toggle if it's a video call
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled; isVideoActive = videoTrack.enabled;
                    toggleVideoButton.innerHTML = videoTrack.enabled ? '<i class="fas fa-video"></i> <span class="hidden sm:inline">Video</span>' : '<i class="fas fa-video-slash"></i> <span class="hidden sm:inline">Video</span>';
                    updateLocalTrackStatus();
                }
            }
        };
        const switchCamera = async () => {
            if (!localStream || !peerConnection || currentCallType !== 'video') return;
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                if (videoDevices.length <= 1) { showErrorMessage("No other cameras found."); return; }

                const currentIndex = videoDevices.findIndex(d => d.deviceId === currentCameraDeviceId);
                const nextCamera = videoDevices[(currentIndex + 1) % videoDevices.length];
                localStream.getTracks().forEach(track => track.stop()); // Stop old tracks

                const newStream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: nextCamera.deviceId }, width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: true // Keep audio constraint consistent
                });
                localVideo.srcObject = newStream; currentCameraDeviceId = nextCamera.deviceId;
                localStream = newStream; // Update global localStream
                peerConnection.getSenders().forEach(sender => {
                    if (sender.track.kind === 'video') sender.replaceTrack(newStream.getVideoTracks()[0]);
                    else if (sender.track.kind === 'audio') sender.replaceTrack(newStream.getAudioTracks()[0]);
                });
                updateLocalTrackStatus();
            } catch (error) { console.error("Error switching camera:", error); showErrorMessage("Failed to switch camera. " + error.message); }
        };
        const toggleChatCallView = () => {
            if (videoCallArea.classList.contains('hidden')) { // Show Call
                videoCallArea.classList.remove('hidden'); messageArea.classList.add('hidden');
                toggleViewButton.innerHTML = '<i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>';
            } else { // Show Chat
                videoCallArea.classList.add('hidden'); messageArea.classList.remove('hidden');
                toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>';
            }
        };

        // --- Event Listeners ---
        verifyKeyButton.addEventListener('click', () => {
            deriveEncryptionKey(sharedSecretInput.value);
            keyWarningDiv.classList.add('hidden');
        });
        gotItButton.addEventListener('click', () => keyWarningDiv.classList.add('hidden'));

        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const messageText = messageInput.value.trim();
            if (!messageText || !db || !userId || !derivedKey) { showErrorMessage("Please enter a shared secret key and a message."); return; }
            try {
                const { encryptedText, iv } = await encryptMessage(messageText);
                const messageData = { senderId: userId, encryptedText, iv, timestamp: serverTimestamp(), type: 'text' };
                const messagesColPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/chat_messages`;
                await addDoc(collection(db, messagesColPath), messageData);
                messageInput.value = ''; hideErrorMessage();
            } catch (error) { console.error("Error sending message:", error); }
        });
        mediaInput.addEventListener('change', async (e) => {
            const file = e.target.files[0]; if (!file) return;
            if (!db || !userId || !derivedKey) { showErrorMessage("Please enter a shared secret key before sharing media."); return; }
            if (file.size > 1024 * 1024 * 2) { showErrorMessage("File size exceeds 2MB. Please choose a smaller file."); return; } // Increased limit slightly
            showErrorMessage("Uploading and encrypting media...");
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const fileBase64 = event.target.result;
                    const { encryptedText, iv } = await encryptMessage(fileBase64);
                    const messageData = {
                        senderId: userId, encryptedContent: encryptedText, iv, timestamp: serverTimestamp(),
                        type: 'media', mediaType: file.type.split('/')[0], fileName: file.name,
                    };
                    const messagesColPath = `artifacts/${initializeApp(window.firebaseConfig).options.projectId}/public/data/chat_messages`;
                    await addDoc(collection(db, messagesColPath), messageData);
                    hideErrorMessage(); e.target.value = '';
                } catch (error) { console.error("Error sharing media:", error); showErrorMessage("Failed to share media. " + error.message); }
            };
            reader.readAsDataURL(file);
        });

        startAudioCallButton.addEventListener('click', () => startCall('audio'));
        startVideoCallButton.addEventListener('click', () => startCall('video'));
        joinCallButton.addEventListener('click', joinExistingCall);
        hangUpButton.addEventListener('click', () => endCall(true)); // true = this user initiated the hangup

        toggleMicButton.addEventListener('click', toggleLocalMic);
        toggleVideoButton.addEventListener('click', toggleLocalVideo);
        switchCamButton.addEventListener('click', switchCamera);
        toggleViewButton.addEventListener('click', toggleChatCallView);

        window.addEventListener('beforeunload', () => {
            stopPresenceUpdates();
            // Consider ending call if user closes tab, but this can be abrupt.
            // if (peerConnection) endCall(true); 
        });

        // Initialize firebaseConfig on window for dynamic access if needed by helper functions before full module load
        // However, it's better to pass db or config around, or ensure initialization order.
        // For simplicity here, I'll reference the config object directly in paths where needed,
        // or ensure app is initialized before such paths are constructed.
        // The initializeApp(window.firebaseConfig) in paths ensures it uses the latest config.
        // Storing it on window is one way if it's needed globally by non-module scripts or for very specific scenarios.
        // For this module, direct access to the `firebaseConfig` const is preferred after `initializeApp`.
        // Let's make sure firebaseConfig is defined when it's used in path construction.
        // The functions constructing paths are typically called after `window.onload` where `firebaseConfig` is defined.
        // I'll use `initializeApp(firebaseConfigFromOnload).options.projectId` to be safe.
        // Or, more simply, since firebaseConfig is a const in the module scope:
        // `artifacts/${firebaseConfig.projectId}/...` once `firebaseConfig` is defined in `window.onload`.
        // For robustness, path strings could be constructed after Firebase init is complete and projectId is confirmed.
        // I have updated the path constructions to use initializeApp(firebaseConfig).options.projectId
        // or directly use the firebaseConfig const if it's in scope and initialized.

    </script>
</body>
</html>
