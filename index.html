<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Chat & Call</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding-bottom: 100px; /* Space for the fixed message form */
        }
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 Aspect Ratio */
            background-color: #333;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        .video-element {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.75rem;
        }
        .local-video-small {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 120px; /* Adjusted for better visibility */
            height: 90px; /* Adjusted for better visibility */
            border-radius: 0.5rem;
            border: 2px solid #fff;
            z-index: 10;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            border-radius: 0.75rem;
            z-index: 5;
        }
        #messageArea {
            max-height: 70vh; 
            overflow-y: auto;
        }
        #messageArea::-webkit-scrollbar { width: 8px; }
        #messageArea::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #messageArea::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #messageArea::-webkit-scrollbar-thumb:hover { background: #555; }

        /* Fullscreen specific styles for videoCallArea if needed */
        #videoCallArea:fullscreen .video-container {
            max-width: 100%;
            max-height: 100%;
            padding-top: 0; /* Adjust if aspect ratio needs to be flexible */
            height: 100%;
        }
        #videoCallArea:fullscreen .local-video-small {
            width: 180px; /* Slightly larger in fullscreen */
            height: 135px;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-100 to-pink-200 text-gray-800">

    <header class="bg-white shadow-md p-4 text-center rounded-b-xl sticky top-0 z-30">
        <h1 class="text-2xl sm:text-3xl font-extrabold text-purple-700">Secure Chat & Call</h1>
        <p class="text-xs sm:text-sm text-gray-600 mt-1">Encrypted messaging and calls for your room.</p>
        <p id="userIdDisplay" class="text-xs text-gray-500 mt-2 hidden">
            Your User ID: <span class="font-mono bg-gray-100 px-2 py-1 rounded-md break-all"></span>
        </p>
    </header>

    <div class="p-4">
        <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md my-4 hidden" role="alert">
            <strong class="font-bold">Error:</strong>
            <span class="block sm:inline ml-2"></span>
        </div>

        <div class="p-4 bg-white shadow-sm rounded-lg my-4 flex flex-col sm:flex-row items-center gap-3">
            <label for="sharedSecret" class="text-sm font-medium text-gray-700 whitespace-nowrap">Shared Secret Key:</label>
            <input id="sharedSecret" type="password" placeholder="Enter shared secret key for room" class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm w-full sm:w-auto"/>
            <button id="verifyKeyButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out">Verify & Enter Room</button>
            <div id="keyWarning" class="text-xs text-red-500 mt-2 sm:mt-0">
                <p><strong>Important:</strong> This key is NOT stored. Re-enter on refresh.</p>
                <p>Share securely with your chat partner OUTSIDE this app.</p>
                <button id="gotItButton" class="text-blue-600 hover:underline mt-1">Got it!</button>
            </div>
        </div>

        <div class="p-4 bg-white shadow-sm rounded-lg my-4 flex flex-col gap-3">
            <div class="flex flex-wrap items-center gap-2">
                <span class="text-sm font-medium text-gray-700">Connected Users (in this room):</span>
                <div id="connectedUsersList" class="flex-1 flex flex-wrap gap-2 text-sm text-gray-600">
                    <span class="text-gray-400 italic">Enter secret key to see users...</span>
                </div>
            </div>
            <div class="flex flex-wrap justify-center gap-2 sm:gap-4 mt-2">
                <button id="startAudioCallButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2" disabled>
                    <i class="fas fa-phone"></i> Audio Call
                </button>
                <button id="startVideoCallButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2" disabled>
                    <i class="fas fa-video"></i> Video Call
                </button>
                <button id="joinCallButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center gap-2">
                    <i class="fas fa-phone-volume"></i> Join Call
                </button>
                <button id="hangUpButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center gap-2">
                    <i class="fas fa-phone-slash"></i> Hang Up
                </button>
            </div>
        </div>

        <div class="relative min-h-[50vh]">
            <div id="videoCallArea" class="absolute inset-0 p-4 hidden flex-col items-center justify-center bg-gray-800 rounded-lg z-10">
                <div class="video-container w-full max-w-2xl"> <video id="remoteVideo" autoplay playsinline class="video-element"></video>
                    <div id="remoteVideoOverlay" class="video-overlay hidden">
                        <i id="remoteMicStatus" class="fas fa-microphone-slash mr-2"></i>
                        <i id="remoteCamStatus" class="fas fa-video-slash"></i>
                    </div>
                    <video id="localVideo" autoplay playsinline muted class="local-video-small"></video>
                </div>
                <p id="callStatus" class="text-white mt-2 text-lg"></p>
                <div class="flex flex-wrap justify-center gap-2 sm:gap-3 mt-4">
                    <button id="toggleMicButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-microphone"></i> <span class="hidden sm:inline">Mic</span>
                    </button>
                    <button id="toggleVideoButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-video"></i> <span class="hidden sm:inline">Video</span>
                    </button>
                    <button id="switchCamButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-camera-rotate"></i> <span class="hidden sm:inline">Switch</span>
                    </button>
                     <button id="toggleFullscreenButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-expand"></i> <span class="hidden sm:inline">Full</span>
                    </button>
                    <button id="toggleViewButton" class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-lg flex items-center gap-2">
                        <i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>
                    </button>
                </div>
            </div>

            <main id="messageArea" class="absolute inset-0 p-4 space-y-4">
                <div id="initialMessage" class="flex justify-center items-center h-full text-gray-500 text-base sm:text-lg italic text-center px-4">
                    <p>Enter a shared secret key above to join or create a secure room and start chatting!</p>
                </div>
                </main>
        </div>
    </div>

    <form id="messageForm" class="bg-white p-3 sm:p-4 shadow-lg rounded-t-xl flex items-center space-x-2 sm:space-x-3 fixed bottom-0 left-0 right-0 w-full z-20">
        <input id="messageInput" type="text" placeholder="Type your message..." class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm sm:text-base" disabled />
        <label for="mediaInput" class="cursor-pointer bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-3 rounded-lg shadow-sm transition duration-300 ease-in-out">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                <path fill-rule="evenodd" d="M1.5 6a2.25 2.25 0 0 1 2.25-2.25h16.5A2.25 2.25 0 0 1 22.5 6v12a2.25 2.25 0 0 1-2.25 2.25H3.75A2.25 2.25 0 0 1 1.5 18V6ZM3 16.06V18c0 .414.336.75.75.75h16.5a.75.75 0 0 0 .75-.75v-1.94l-2.432-2.432a1.125 1.125 0 0 0-1.588 0L9.407 17.11c-.095.095-.22.14-.345.14-.125 0-.25-.045-.345-.14l-4.16-4.16a1.125 1.125 0 0 0-1.588 0L3 16.06ZM15.75 9.75a.75.75 0 0 1 .75-.75h.008a.75.75 0 0 1 .75.75v.008a.75.75 0 0 1-.75.75h-.008a.75.75 0 0 1-.75-.75V9.75Z" clip-rule="evenodd" />
            </svg>
            <input type="file" id="mediaInput" class="hidden" accept="image/*,video/*,audio/*" disabled>
        </label>
        <button id="sendButton" type="submit" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-5 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed text-sm sm:text-base" disabled>
            Send
        </button>
    </form>

    <script type="module">
        // Firebase V10.6.0 imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js"; // Removed signInWithCustomToken
        import { getFirestore, collection, doc, addDoc, onSnapshot, serverTimestamp, query, where, setDoc, deleteDoc, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js";

        // Firebase app instances and config - module-scoped
        let app;
        let db;
        let auth;
        let firebaseConfig; // Will be assigned in window.onload with hardcoded values

        // Application state variables
        let userId = null;
        let derivedKey = null; // CryptoKey for AES-GCM
        let messages = [];
        let messagesUnsubscribe = null; // Firestore listener for messages
        let presenceUnsubscribe = null; // Firestore listener for presence
        let callStateUnsubscribe = null; // Firestore listener for call state
        let candidatesUnsubscribe = null; // Firestore listener for ICE candidates

        let peerConnection = null;
        let localStream = null;
        let callRoomId = null; // Derived from shared secret, used as Firestore document ID for calls and roomId for messages/presence
        let presenceInterval = null;
        
        let currentCameraDeviceId = null; // To store ID of current camera
        let isVideoActive = true; // Local video track state
        let isAudioActive = true; // Local audio track state
        let currentCallType = 'video'; // 'video' or 'audio'
        let makingOffer = false; // Flag to prevent renegotiation races
        let processingRemoteSignal = false; // Flag to manage incoming signal processing

        // WebRTC configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ],
        };

        // DOM Element references (remains unchanged)
        const userIdDisplay = document.getElementById('userIdDisplay');
        const userIdSpan = userIdDisplay.querySelector('span');
        const errorMessageDiv = document.getElementById('errorMessage');
        const errorMessageSpan = errorMessageDiv.querySelector('span');
        const sharedSecretInput = document.getElementById('sharedSecret');
        const verifyKeyButton = document.getElementById('verifyKeyButton');
        const keyWarningDiv = document.getElementById('keyWarning');
        const gotItButton = document.getElementById('gotItButton');
        const messageArea = document.getElementById('messageArea');
        const initialMessageDiv = document.getElementById('initialMessage');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const mediaInput = document.getElementById('mediaInput');
        const connectedUsersList = document.getElementById('connectedUsersList');
        const startAudioCallButton = document.getElementById('startAudioCallButton');
        const startVideoCallButton = document.getElementById('startVideoCallButton');
        const joinCallButton = document.getElementById('joinCallButton');
        const hangUpButton = document.getElementById('hangUpButton');
        const videoCallArea = document.getElementById('videoCallArea');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const callStatus = document.getElementById('callStatus');
        const toggleMicButton = document.getElementById('toggleMicButton');
        const toggleVideoButton = document.getElementById('toggleVideoButton');
        const switchCamButton = document.getElementById('switchCamButton');
        const toggleFullscreenButton = document.getElementById('toggleFullscreenButton');
        const toggleViewButton = document.getElementById('toggleViewButton');
        const remoteVideoOverlay = document.getElementById('remoteVideoOverlay');
        const remoteMicStatus = document.getElementById('remoteMicStatus');
        const remoteCamStatus = document.getElementById('remoteCamStatus');


        // Helper functions for Base64 conversion (remains unchanged)
        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return btoa(binary);
        };
        const base64ToArrayBuffer = (base64) => {
            const binary_string = atob(base64);
            const bytes = new Uint8Array(binary_string.length);
            for (let i = 0; i < binary_string.length; i++) bytes[i] = binary_string.charCodeAt(i);
            return bytes.buffer;
        };

        // UI Helper: Show/Hide Error Messages (remains unchanged)
        const showErrorMessage = (message) => {
            errorMessageSpan.textContent = message;
            errorMessageDiv.classList.remove('hidden');
            setTimeout(() => {
                if (errorMessageSpan.textContent === message) hideErrorMessage();
            }, 7000);
        };
        const hideErrorMessage = () => {
            errorMessageDiv.classList.add('hidden');
            errorMessageSpan.textContent = '';
        };
        
        // Path construction helpers using module-scoped firebaseConfig.projectId
        const getArtifactsBasePath = () => {
            if (!firebaseConfig || !firebaseConfig.projectId) { 
                console.error("Firebase config (with projectId) not ready for path construction."); 
                return null; 
            }
            return `artifacts/${firebaseConfig.projectId}/public/data`;
        };
        const getMessagesColPath = () => { const basePath = getArtifactsBasePath(); return basePath ? `${basePath}/chat_messages_v2` : null; };
        const getPresenceColPath = () => { const basePath = getArtifactsBasePath(); return basePath ? `${basePath}/presence_v2` : null; };
        const getPresenceDocPath = (currentUserId) => { const colPath = getPresenceColPath(); return colPath && currentUserId ? `${colPath}/${currentUserId}` : null; };
        const getCallDocPath = (currentCallRoomId) => { const basePath = getArtifactsBasePath(); return basePath && currentCallRoomId ? `${basePath}/calls_v2/${currentCallRoomId}` : null; };
        const getCallCandidatesColPath = (currentCallRoomId) => { const callDocP = getCallDocPath(currentCallRoomId); return callDocP ? `${callDocP}/candidates` : null; };

        // Cryptography: Derive Key, Encrypt, Decrypt (remains unchanged)
        const deriveEncryptionKey = async (secret) => {
            // Clear previous state if any
            if (messagesUnsubscribe) { messagesUnsubscribe(); messagesUnsubscribe = null; }
            if (presenceUnsubscribe) { presenceUnsubscribe(); presenceUnsubscribe = null; }
            if (callStateUnsubscribe) { callStateUnsubscribe(); callStateUnsubscribe = null; }
            if (candidatesUnsubscribe) { candidatesUnsubscribe(); candidatesUnsubscribe = null; }
            
            messages = [];
            derivedKey = null;
            callRoomId = null; 
            renderMessages(); 
            updatePresenceUI([]); 

            messageInput.disabled = true; sendButton.disabled = true; mediaInput.disabled = true;
            startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
            joinCallButton.classList.add('hidden');
            stopPresenceUpdates();

            if (!secret) {
                 showErrorMessage("Please enter a secret key.");
                 return;
            }

            try {
                const enc = new TextEncoder();
                const salt = enc.encode('secure-chat-salt-v2'); 
                const keyMaterial = await window.crypto.subtle.importKey('raw', enc.encode(secret), { name: 'PBKDF2' }, false, ['deriveKey']);
                const derived = await window.crypto.subtle.deriveKey(
                    { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                derivedKey = derived;
                
                const keyHashBuffer = await crypto.subtle.digest('SHA-256', enc.encode(secret + '-room-id-v2')); 
                callRoomId = arrayBufferToBase64(keyHashBuffer).replace(/[^a-zA-Z0-9]/g, '').substring(0, 40); 

                hideErrorMessage();
                messageInput.disabled = false; sendButton.disabled = false; mediaInput.disabled = false;
                
                subscribeToMessages(callRoomId);
                initializeCallListeners(callRoomId); 
                startPresenceUpdates();
                subscribeToPresence(callRoomId);

            } catch (error) {
                console.error("Error deriving key:", error);
                showErrorMessage("Failed to derive encryption key. Check secret or console.");
                derivedKey = null; callRoomId = null;
                messageInput.disabled = true; sendButton.disabled = true; mediaInput.disabled = true;
                startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
                joinCallButton.classList.add('hidden');
                stopPresenceUpdates();
                renderMessages(); 
                updatePresenceUI([]);
            }
        };

        const autoDecryptMessages = async () => {
            if (!derivedKey) return;
            let hasNewDecryptions = false;
            const newMessages = await Promise.all(messages.map(async (msg) => {
                if ((msg.encryptedText || msg.encryptedContent) && msg.iv && !msg.isDecrypted) {
                    const contentToDecrypt = msg.type === 'media' ? msg.encryptedContent : msg.encryptedText;
                    try {
                        const decryptedContent = await decryptMessage(contentToDecrypt, msg.iv);
                        hasNewDecryptions = true;
                        return { ...msg, decryptedText: decryptedContent, isDecrypted: true, decryptionError: null };
                    } catch (error) {
                        console.warn(`Decryption failed for message ${msg.id}:`, error.message);
                        return { ...msg, decryptedText: null, isDecrypted: false, decryptionError: "Decryption failed. Wrong key or corrupted." };
                    }
                }
                return msg; 
            }));
            messages = newMessages;
            if (hasNewDecryptions || messages.length > 0) { 
                 renderMessages();
            }
        };

        const encryptMessage = async (text) => {
            if (!derivedKey) { showErrorMessage("Encryption key not ready."); throw new Error("Encryption key not ready."); }
            try {
                const enc = new TextEncoder(); const encoded = enc.encode(text);
                const iv = window.crypto.getRandomValues(new Uint8Array(12)); 
                const ciphertext = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, derivedKey, encoded);
                return { encryptedText: arrayBufferToBase64(ciphertext), iv: arrayBufferToBase64(iv) };
            } catch (error) { console.error("Encryption failed:", error); showErrorMessage("Failed to encrypt message."); throw error; }
        };

        const decryptMessage = async (encryptedData, ivBase64) => {
            if (!derivedKey) { showErrorMessage("Decryption key not ready."); throw new Error("Decryption key not ready."); }
            try {
                const ciphertext = base64ToArrayBuffer(encryptedData); const iv = base64ToArrayBuffer(ivBase64);
                const decrypted = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv }, derivedKey, ciphertext);
                return new TextDecoder().decode(decrypted);
            } catch (error) { console.error("Decryption failed:", error); throw new Error("Decryption failed. Incorrect key or corrupted message."); }
        };
        
        // UI: Render Messages (remains unchanged from previous update logic)
        const renderMessages = () => {
            messageArea.innerHTML = ''; 

            if (!derivedKey || !callRoomId) { 
                initialMessageDiv.classList.remove('hidden');
                messageArea.appendChild(initialMessageDiv);
                return;
            }
            
            initialMessageDiv.classList.add('hidden'); 

            if (messages.length === 0) {
                const noMessagesInRoomDiv = document.createElement('div');
                noMessagesInRoomDiv.className = "flex justify-center items-center h-full text-gray-500 text-base sm:text-lg italic text-center px-4";
                noMessagesInRoomDiv.innerHTML = "<p>No messages in this room yet. Be the first to send one!</p>";
                messageArea.appendChild(noMessagesInRoomDiv);
                return;
            }

            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${msg.senderId === userId ? 'justify-end' : 'justify-start'} mb-2`;

                const contentDiv = document.createElement('div');
                contentDiv.className = `max-w-[80%] p-3 rounded-xl shadow-md flex flex-col ${msg.senderId === userId ? 'bg-purple-500 text-white rounded-br-none' : 'bg-white text-gray-800 rounded-bl-none'}`;
                
                const senderSpan = document.createElement('span');
                senderSpan.className = 'text-xs opacity-80 mb-1';
                senderSpan.textContent = msg.senderId === userId ? 'You' : `User: ${msg.senderId ? msg.senderId.substring(0, 8) : 'Unknown'}...`;
                contentDiv.appendChild(senderSpan);

                if (msg.type === 'media' && (msg.encryptedContent || msg.decryptedText)) { 
                    if (msg.isDecrypted && msg.decryptedText) {
                        let mediaElement;
                        if (msg.mediaType === 'image') { mediaElement = document.createElement('img'); mediaElement.src = msg.decryptedText; }
                        else if (msg.mediaType === 'video') { mediaElement = document.createElement('video'); mediaElement.src = msg.decryptedText; mediaElement.controls = true; mediaElement.autoplay = false; mediaElement.playsInline = true; } 
                        else if (msg.mediaType === 'audio') { mediaElement = document.createElement('audio'); mediaElement.src = msg.decryptedText; mediaElement.controls = true; }
                        if (mediaElement) { mediaElement.className = 'max-w-xs sm:max-w-sm md:max-w-md h-auto rounded-md my-1'; contentDiv.appendChild(mediaElement); } 
                    } else {
                        const encryptedP = document.createElement('p'); encryptedP.className = 'text-sm italic text-gray-400 break-words';
                        encryptedP.textContent = `Encrypted ${msg.mediaType || 'media'} (${msg.fileName || 'unknown'}). Waiting for key...`; 
                        contentDiv.appendChild(encryptedP);
                        if (msg.decryptionError) { const errorP = document.createElement('p'); errorP.className = 'text-xs text-red-300 mt-1'; errorP.textContent = `${msg.decryptionError}`; contentDiv.appendChild(errorP); }
                    }
                } else if (msg.encryptedText || msg.decryptedText) { 
                     if (msg.isDecrypted && msg.decryptedText) { 
                        const decryptedP = document.createElement('p'); decryptedP.className = 'text-sm break-words whitespace-pre-wrap'; decryptedP.textContent = msg.decryptedText; contentDiv.appendChild(decryptedP); 
                    } else {
                        const encryptedP = document.createElement('p'); encryptedP.className = 'text-sm italic text-gray-400 break-words';
                        encryptedP.textContent = `Encrypted: ${msg.encryptedText ? msg.encryptedText.substring(0,20) : ''}... Waiting for key.`; 
                        contentDiv.appendChild(encryptedP);
                        if (msg.decryptionError) { const errorP = document.createElement('p'); errorP.className = 'text-xs text-red-300 mt-1'; errorP.textContent = `${msg.decryptionError}`; contentDiv.appendChild(errorP); }
                    }
                }
                const timestampSpan = document.createElement('span'); 
                timestampSpan.className = 'text-xs opacity-75 mt-1 block text-right';
                if (msg.timestamp?.toDate) timestampSpan.textContent = msg.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                else if (msg.timestamp) timestampSpan.textContent = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                contentDiv.appendChild(timestampSpan); messageDiv.appendChild(contentDiv); messageArea.appendChild(messageDiv);
            });
            messageArea.scrollTop = messageArea.scrollHeight;
        };

        // Firebase: Subscribe to Messages for a specific room (remains unchanged from previous update)
        function subscribeToMessages(currentRoomId) {
            if (messagesUnsubscribe) {
                messagesUnsubscribe(); 
                messagesUnsubscribe = null;
            }
            messages = []; 
            renderMessages(); 

            if (!db || !currentRoomId) {
                console.warn("DB or currentRoomId not available for message subscription.");
                return;
            }
            
            const messagesPath = getMessagesColPath();
            if (!messagesPath) {
                console.error("Messages collection path could not be determined for subscription.");
                renderMessages(); 
                return;
            }

            const q = query(collection(db, messagesPath), where("roomId", "==", currentRoomId));
            
            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                const fetchedMessages = snapshot.docs.map(d => ({ 
                    id: d.id, 
                    ...d.data(), 
                    decryptedText: null, 
                    isDecrypted: false, 
                    decryptionError: null 
                }));
                fetchedMessages.sort((a, b) => (a.timestamp?.toDate()?.getTime() || 0) - (b.timestamp?.toDate()?.getTime() || 0));
                messages = fetchedMessages;
                renderMessages(); 
                if (derivedKey) { 
                    autoDecryptMessages();
                }
            }, (error) => {
                console.error("Error fetching messages for room:", currentRoomId, error);
                showErrorMessage("Failed to fetch messages for the room.");
                messages = []; 
                renderMessages(); 
            });
        }
        
        // Firebase: Initialization & Auth (Reverted to original hardcoded config)
        window.onload = async () => {
            try {
                // User's original hardcoded Firebase config
                firebaseConfig = { 
                    apiKey: "AIzaSyCPmT3kxQm4nqovB1eB5tWON2GCStcSzmg", 
                    authDomain: "sybau-2b8ae.firebaseapp.com",
                    projectId: "sybau-2b8ae",
                    storageBucket: "sybau-2b8ae.appspot.com", 
                    messagingSenderId: "973974019830",     
                    appId: "1:973974019830:web:2dfc448a43178aea6116d7" 
                };
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User is signed in with UID:", userId);
                        userIdSpan.textContent = userId; 
                        userIdDisplay.classList.remove('hidden');
                        renderMessages(); // Initial render (will show "enter secret key" if no room yet)
                    } else {
                        console.log("No user signed in, attempting anonymous sign-in.");
                        userId = null; 
                        userIdDisplay.classList.add('hidden');
                        try {
                            await signInAnonymously(auth);
                            console.log("Signed in anonymously.");
                            // onAuthStateChanged will be triggered again with the new user
                        } catch (anonError) {
                            console.error("Anonymous sign-in failed:", anonError);
                            showErrorMessage("Authentication failed. Please refresh.");
                        }
                    }
                });
            } catch (error) { 
                console.error("Firebase init error:", error); 
                showErrorMessage("App initialization failed. Check console and config."); 
            }
        };
        
        // Presence System (remains unchanged from previous update logic)
        const updatePresence = async () => {
            if (db && userId && callRoomId) { 
                const path = getPresenceDocPath(userId);
                if (path) {
                    try {
                        await setDoc(doc(db, path), { lastSeen: serverTimestamp(), roomId: callRoomId }, { merge: true });
                    } catch (e) {
                        console.warn("Failed to update presence:", e.message);
                    }
                }
            }
        };
        const startPresenceUpdates = () => { 
            if (presenceInterval) clearInterval(presenceInterval); 
            updatePresence(); 
            presenceInterval = setInterval(updatePresence, 20000); 
        };
        const stopPresenceUpdates = () => {
            if (presenceInterval) { clearInterval(presenceInterval); presenceInterval = null; }
        };

        const updatePresenceUI = (activeUserIds) => {
            connectedUsersList.innerHTML = '';
            if (!callRoomId) { 
                 connectedUsersList.innerHTML = '<span class="text-gray-400 italic">Enter secret key to see users...</span>';
                 startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
                 return;
            }
            if (activeUserIds.length === 0) {
                connectedUsersList.innerHTML = '<span class="text-gray-400 italic">No other users in this room yet...</span>';
                startAudioCallButton.disabled = true; startVideoCallButton.disabled = true;
            } else {
                activeUserIds.forEach(id => {    
                    const userSpan = document.createElement('span');
                    userSpan.className = `bg-purple-200 text-purple-800 px-2 py-1 rounded-full text-xs ${id === userId ? 'font-bold ring-2 ring-purple-500' : ''}`; 
                    userSpan.textContent = id === userId ? 'You (Online)' : `User: ${id.substring(0, 8)}...`;
                    connectedUsersList.appendChild(userSpan);
                });
                const otherUsersPresent = activeUserIds.some(id => id !== userId);
                startAudioCallButton.disabled = !otherUsersPresent; 
                startVideoCallButton.disabled = !otherUsersPresent;
            }
        };

        function subscribeToPresence(currentRoomId) {
            if (presenceUnsubscribe) { presenceUnsubscribe(); presenceUnsubscribe = null; }
            if (!db || !currentRoomId) { updatePresenceUI([]); return; }

            const presencePath = getPresenceColPath();
            if (!presencePath) { console.error("Presence collection path missing."); updatePresenceUI([]); return; }

            const q = query(collection(db, presencePath), where("roomId", "==", currentRoomId));
            presenceUnsubscribe = onSnapshot(q, (snapshot) => {
                if (!callRoomId || callRoomId !== currentRoomId) return; 
                const now = Date.now();
                const activeUsers = snapshot.docs
                    .filter(d => d.data().lastSeen && (now - d.data().lastSeen.toDate().getTime() < 60000)) 
                    .map(d => d.id);
                updatePresenceUI(activeUsers);
            }, (error) => { 
                console.error("Presence listener error:", error); 
                showErrorMessage("Could not update user list.");
                updatePresenceUI([]);
            });
        }
        
        // WebRTC Call Logic (remains unchanged from previous update logic)
        function initializeCallListeners(currentCallRoomId) {
            if (callStateUnsubscribe) callStateUnsubscribe();
            if (candidatesUnsubscribe) candidatesUnsubscribe();

            if (!currentCallRoomId || !db) { console.warn("CallRoomId or DB not ready for call listeners."); return; }

            const callDocP = getCallDocPath(currentCallRoomId);
            if (!callDocP) { console.error("Could not get call document path for listener."); return; }
            const callStateRef = doc(db, callDocP);

            callStateUnsubscribe = onSnapshot(callStateRef, async (docSnap) => {
                if (!callRoomId || callRoomId !== currentCallRoomId) return; 

                if (!docSnap.exists()) {
                    if (peerConnection) endCall(false); 
                    callStatus.textContent = 'Call has ended or does not exist.';
                    startAudioCallButton.classList.remove('hidden'); startVideoCallButton.classList.remove('hidden');
                    joinCallButton.classList.add('hidden'); hangUpButton.classList.add('hidden');
                    if (!messageArea.classList.contains('hidden')) { 
                         videoCallArea.classList.add('hidden'); messageArea.classList.remove('hidden');
                         toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>';
                    }
                    return;
                }
                const data = docSnap.data();
                currentCallType = data.callType || 'video'; 

                if ((data.status === 'ringing' || data.status === 'active') && data.callerId !== userId && !peerConnection) {
                    startAudioCallButton.classList.add('hidden'); startVideoCallButton.classList.add('hidden');
                    joinCallButton.classList.remove('hidden'); hangUpButton.classList.add('hidden');
                    callStatus.textContent = `${data.status === 'ringing' ? 'Incoming' : ''} ${currentCallType} call...`;
                    if(messageArea.classList.contains('hidden')) { 
                        // no op
                    } else {
                        videoCallArea.classList.remove('hidden'); messageArea.classList.add('hidden');
                        toggleViewButton.innerHTML = '<i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>';
                    }
                } else if (data.status === 'ended' && peerConnection) {
                    endCall(false); showErrorMessage("Call ended by other user.");
                }

                if (data.offer && data.offer.senderId !== userId && peerConnection) {
                    if (processingRemoteSignal) { console.warn("Already processing a remote signal, ignoring new offer."); return; }
                    processingRemoteSignal = true;
                    console.log(`Processing received offer. Current signalingState: ${peerConnection.signalingState}`);
                    
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                        console.log(`Remote description (offer) set. SignalingState after SRD: ${peerConnection.signalingState}`);
                        if (peerConnection.signalingState === "have-remote-offer") {
                            const answer = await peerConnection.createAnswer();
                            console.log("Answer created. SignalingState before SLD (answer):", peerConnection.signalingState);
                            if (peerConnection.signalingState === "have-remote-offer") { 
                                await peerConnection.setLocalDescription(answer);
                                console.log(`Local description (answer) set. SignalingState after SLD: ${peerConnection.signalingState}`);
                                await setDoc(callStateRef, { answer: { sdp: answer.sdp, type: answer.type, senderId: userId }, status: 'active' }, { merge: true });
                                callStatus.textContent = 'Call active.';    
                                joinCallButton.classList.add('hidden');    
                                hangUpButton.classList.remove('hidden');
                            } else { console.error(`Cannot set local answer. State is ${peerConnection.signalingState}, not have-remote-offer.`); }
                        } else { console.error(`Cannot create answer. SignalingState is ${peerConnection.signalingState}, expected have-remote-offer.`); }
                    } catch(e) {
                        console.error("Error processing offer (setRemoteDescription or subsequent ops):", e, "Signaling state at catch:", peerConnection?.signalingState);
                    } finally {
                        processingRemoteSignal = false;
                    }
                } else if (data.answer && data.answer.senderId !== userId && peerConnection && peerConnection.signalingState === 'have-local-offer') {
                    if (processingRemoteSignal) { console.warn("Already processing a remote signal, ignoring new answer."); return; }
                    processingRemoteSignal = true;
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                        callStatus.textContent = 'Call connected!';
                        console.log(`Remote description (answer) set. SignalingState after SRD (answer): ${peerConnection.signalingState}`);
                    } catch(e) {
                        console.error("Error processing answer:", e, "Signaling state:", peerConnection?.signalingState);
                    } finally {
                        processingRemoteSignal = false;
                    }
                }
                if (data.trackStatus && data.trackStatus.senderId !== userId) {    
                    remoteMicStatus.classList.toggle('fa-microphone', data.trackStatus.audio);
                    remoteMicStatus.classList.toggle('fa-microphone-slash', !data.trackStatus.audio);
                    remoteCamStatus.classList.toggle('fa-video', data.trackStatus.video);
                    remoteCamStatus.classList.toggle('fa-video-slash', !data.trackStatus.video);
                    remoteVideoOverlay.classList.toggle('hidden', data.trackStatus.video); 
                }
            }, (error) => { console.error("Call state listener error:", error); showErrorMessage("Call connection error."); });

            const candidatesPath = getCallCandidatesColPath(currentCallRoomId);
            if (candidatesPath) {
                candidatesUnsubscribe = onSnapshot(query(collection(db, candidatesPath)), (snapshot) => {
                    if (!callRoomId || callRoomId !== currentCallRoomId) return; 
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added' && peerConnection) {
                            const candidateData = change.doc.data();
                            if (candidateData.senderId !== userId) {
                                try { 
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData.candidate)); 
                                    console.log("Added remote ICE candidate");
                                }    
                                catch (e) { console.warn('Error adding received ICE candidate:', e.message); } 
                            }
                        }
                    });
                });
            } else {
                console.error("Candidates collection path could not be determined for listener.");
            }
        }

        const setupPeerConnection = async (callType) => {
            console.log("setupPeerConnection called for type:", callType, ". Current peerConnection:", peerConnection);
            if (peerConnection) {
                console.log("Closing existing peer connection. State:", peerConnection.signalingState);
                try { peerConnection.close(); } catch(e) { console.warn("Error closing previous peer connection:", e); }
                peerConnection = null;    
            }

            try {
                peerConnection = new RTCPeerConnection(rtcConfig);    
                console.log("New RTCPeerConnection object created:", peerConnection);
                if (!peerConnection || typeof peerConnection.addTrack !== 'function') {
                    throw new Error("RTCPeerConnection instantiation failed or missing addTrack.");    
                }
            } catch (e) {
                console.error("Error creating RTCPeerConnection:", e);
                showErrorMessage("WebRTC setup failed: " + e.message);
                if (peerConnection) { try { peerConnection.close(); } catch(closeError) { /* ignore */ } peerConnection = null; }
                throw e; 
            }
            
            currentCallType = callType; 

            peerConnection.onicecandidate = async (event) => {
                if (event.candidate && callRoomId) {
                    const path = getCallCandidatesColPath(callRoomId);
                    if (path) await addDoc(collection(db, path), { senderId: userId, candidate: event.candidate.toJSON(), timestamp: serverTimestamp() });
                    else console.error("Cannot send ICE candidate, path is null.");
                }
            };
            peerConnection.ontrack = (event) => { 
                if (remoteVideo.srcObject !== event.streams[0]) { 
                    remoteVideo.srcObject = event.streams[0]; 
                    callStatus.textContent = 'Connected!'; 
                    console.log("Remote track received and set.");
                } 
            };
            
            peerConnection.onnegotiationneeded = async () => {
                if (makingOffer || processingRemoteSignal || !peerConnection || peerConnection.signalingState !== 'stable' || !callRoomId) {
                    console.log("onnegotiationneeded: skipped. makingOffer:", makingOffer, "processingRemoteSignal:", processingRemoteSignal, "signalingState:", peerConnection?.signalingState);
                    return;
                }
                makingOffer = true;
                console.log("onnegotiationneeded: Attempting to create and set offer. Current signalingState:", peerConnection.signalingState);
                try {
                    const offer = await peerConnection.createOffer();
                    if (peerConnection.signalingState !== 'stable') {    
                        console.warn("onnegotiationneeded: Signaling state changed to", peerConnection.signalingState, "before setLocalDescription. Aborting.");
                        makingOffer = false; return;
                    }
                    await peerConnection.setLocalDescription(offer);
                    const path = getCallDocPath(callRoomId);
                    if (path) {
                        await setDoc(doc(db, path), { offer: { sdp: offer.sdp, type: offer.type, senderId: userId } }, { merge: true });
                    } else { console.error("onnegotiationneeded: Cannot send renegotiation offer, path is null."); }
                } catch (e) { console.error('Renegotiation error (onnegotiationneeded):', e);
                } finally { makingOffer = false; }
            };

            try {
                const videoConstraint = callType === 'video' ? { width: { ideal: 640 }, height: { ideal: 480 } } : false;
                if (currentCameraDeviceId && callType === 'video' && videoConstraint) {
                    videoConstraint.deviceId = { exact: currentCameraDeviceId };
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraint, audio: true });
                localVideo.srcObject = localStream;
                
                if (!currentCameraDeviceId && callType === 'video' && localStream.getVideoTracks().length > 0) {
                    currentCameraDeviceId = localStream.getVideoTracks()[0].getSettings().deviceId;
                }
                
                if (!peerConnection) { throw new Error("peerConnection became null before adding tracks."); }
                localStream.getTracks().forEach(track => {
                    if (peerConnection && typeof peerConnection.addTrack === 'function') {    
                        peerConnection.addTrack(track, localStream);
                    } else { console.error("Cannot add track, peerConnection invalid."); }
                });

                isVideoActive = callType === 'video' && localStream.getVideoTracks().some(t => t.enabled);
                isAudioActive = localStream.getAudioTracks().some(t => t.enabled);
                updateLocalTrackStatusUI(); 
                await updateLocalTrackStatus(); 
                toggleVideoButton.style.display = callType === 'video' ? 'flex' : 'none';
                switchCamButton.style.display = callType === 'video' ? 'flex' : 'none';

            } catch (error) {    
                console.error('getUserMedia or track addition error:', error);    
                showErrorMessage('Cam/Mic access or track setup failed: ' + error.message);
                if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; }
                if (peerConnection) { try { peerConnection.close(); } catch(e) {/*ignore*/} peerConnection = null; }
                throw error; 
            }
        };

        const updateLocalTrackStatus = async () => { 
            if (db && callRoomId && userId && peerConnection) { 
                const path = getCallDocPath(callRoomId);
                if (path) {
                    try {
                        await setDoc(doc(db, path), { trackStatus: { senderId: userId, video: isVideoActive, audio: isAudioActive, timestamp: serverTimestamp() } }, { merge: true });
                    } catch (e) {
                        console.warn("Failed to update track status to Firestore:", e.message);
                    }
                }
            }
        };
        
        const updateLocalTrackStatusUI = () => { 
            toggleMicButton.innerHTML = isAudioActive ? '<i class="fas fa-microphone"></i> <span class="hidden sm:inline">Mic</span>' : '<i class="fas fa-microphone-slash text-red-500"></i> <span class="hidden sm:inline">Mic</span>';
            if (currentCallType === 'video') {
                toggleVideoButton.innerHTML = isVideoActive ? '<i class="fas fa-video"></i> <span class="hidden sm:inline">Video</span>' : '<i class="fas fa-video-slash text-red-500"></i> <span class="hidden sm:inline">Video</span>';
                localVideo.style.visibility = isVideoActive ? 'visible' : 'hidden';
            }
        };


        const startCall = async (callType) => {
            if (!derivedKey || !callRoomId) { showErrorMessage("Verify secret key first to enter a room."); return; }
            if (peerConnection && peerConnection.connectionState !== 'closed' && peerConnection.connectionState !== 'failed') { showErrorMessage("Call already in progress or starting."); return; }
            
            currentCallType = callType; 
            videoCallArea.classList.remove('hidden'); messageArea.classList.add('hidden');
            startAudioCallButton.classList.add('hidden'); startVideoCallButton.classList.add('hidden');
            joinCallButton.classList.add('hidden'); hangUpButton.classList.remove('hidden');
            toggleViewButton.innerHTML = '<i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>';
            callStatus.textContent = `Starting ${callType} call...`;

            try {
                await setupPeerConnection(callType);    
                if (!peerConnection) {    
                    throw new Error('Failed to initialize call connection.');
                }
                
                const offer = await peerConnection.createOffer();    
                await peerConnection.setLocalDescription(offer);
                const path = getCallDocPath(callRoomId);
                if (path) {
                    await setDoc(doc(db, path), { offer: { sdp: offer.sdp, type: offer.type, senderId: userId }, status: 'ringing', callerId: userId, callType, timestamp: serverTimestamp() });
                    callStatus.textContent = 'Waiting for peer...';
                } else {
                    throw new Error('Failed to start call. Path error.');
                }
            } catch (error) {    
                console.error("Error during call initiation (setup or offer):", error);
                showErrorMessage(error.message || "Failed to start call.");
                endCall(true); 
            }
        };

        const joinExistingCall = async () => {
            if (!derivedKey || !callRoomId) { showErrorMessage("Verify secret key first to enter a room."); return; }
            if (peerConnection && peerConnection.connectionState !== 'closed' && peerConnection.connectionState !== 'failed') { showErrorMessage("Already in call or starting."); return; }
            
            const path = getCallDocPath(callRoomId);
            if (!path) { showErrorMessage("Call path error."); return; }
            
            try {
                const callDocSnap = await getDoc(doc(db, path));
                if (!callDocSnap.exists() || !callDocSnap.data().callType) { showErrorMessage("Call details missing or call does not exist."); return; }
                currentCallType = callDocSnap.data().callType; 
                
                videoCallArea.classList.remove('hidden'); messageArea.classList.add('hidden');
                startAudioCallButton.classList.add('hidden'); startVideoCallButton.classList.add('hidden');
                joinCallButton.classList.add('hidden'); hangUpButton.classList.remove('hidden');
                toggleViewButton.innerHTML = '<i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>';
                callStatus.textContent = `Joining ${currentCallType} call...`;

                await setupPeerConnection(currentCallType); 
                if (!peerConnection) {
                    throw new Error('Failed to initialize call connection for joining.');
                }
                console.log("Peer connection set up for joining call. Waiting for signaling via Firestore.");
            } catch (error) {
                console.error("Error during join call (setup or getDoc):", error);
                showErrorMessage(error.message || "Failed to join call.");
                endCall(true); 
            }
        };

        const endCall = async (isInitiator = true) => {
            console.log("endCall called. isInitiator:", isInitiator, "PC state:", peerConnection?.signalingState);
            if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; localVideo.srcObject = null; }
            if (remoteVideo.srcObject) { remoteVideo.srcObject.getTracks().forEach(t => t.stop()); remoteVideo.srcObject = null; }
            
            if (peerConnection) { 
                peerConnection.getSenders().forEach(sender => {
                    if (sender.track) {
                        try { peerConnection.removeTrack(sender); } catch(e) { console.warn("Error removing track:", e); }
                    }
                });
                try {peerConnection.close();} catch(e){console.warn("Error closing PC in endCall:", e);} 
                peerConnection = null; 
            }
            
            makingOffer = false; processingRemoteSignal = false;

            if (isInitiator && db && callRoomId) {
                const path = getCallDocPath(callRoomId);
                if (path) {
                    try { await deleteDoc(doc(db, path)); console.log("Call document deleted."); }
                    catch (e) { console.error("Call doc delete error:", e); }
                }
                const candidatesPath = getCallCandidatesColPath(callRoomId);
                if (candidatesPath) {
                    try { 
                        const snapshot = await getDocs(query(collection(db, candidatesPath))); 
                        snapshot.forEach(d => deleteDoc(d.ref)); 
                        console.log("ICE candidates cleared.");
                    }    
                    catch (e) { console.error("Candidates delete error:", e); }
                }
            }
            videoCallArea.classList.add('hidden'); messageArea.classList.remove('hidden');
            startAudioCallButton.classList.remove('hidden'); startVideoCallButton.classList.remove('hidden');
            joinCallButton.classList.add('hidden'); hangUpButton.classList.add('hidden');
            callStatus.textContent = '';
            isVideoActive = true; isAudioActive = true; 
            updateLocalTrackStatusUI(); 
            toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>';
            remoteVideoOverlay.classList.add('hidden'); 

            if(callRoomId) subscribeToPresence(callRoomId); else updatePresenceUI([]);
        };

        // Call UI Controls (remains unchanged from previous update)
        const toggleLocalMic = async () => {
            if (!localStream || !peerConnection) return;
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                isAudioActive = audioTrack.enabled;
                updateLocalTrackStatusUI();
                await updateLocalTrackStatus(); 
            }
        };

        const toggleLocalVideo = async () => {
            if (currentCallType !== 'video' || !localStream || !peerConnection) return;
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                isVideoActive = videoTrack.enabled;
                updateLocalTrackStatusUI();
                await updateLocalTrackStatus(); 
            }
        };

        const switchCamera = async () => {
            if (currentCallType !== 'video' || !localStream || !peerConnection) {
                showErrorMessage("Video call not active or stream unavailable.");
                return;
            }
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                if (videoDevices.length < 2) {
                    showErrorMessage("No other camera found to switch to.");
                    return;
                }

                const currentVideoTrack = localStream.getVideoTracks()[0];
                currentCameraDeviceId = currentVideoTrack.getSettings().deviceId;
                
                let nextDeviceId = videoDevices.find(device => device.deviceId !== currentCameraDeviceId)?.deviceId;
                if (!nextDeviceId && videoDevices.length > 0) nextDeviceId = videoDevices[0].deviceId; 

                if (!nextDeviceId || nextDeviceId === currentCameraDeviceId) {
                     showErrorMessage("Could not determine next camera."); return;
                }

                currentVideoTrack.stop();

                const newConstraints = { 
                    video: { deviceId: { exact: nextDeviceId }, width: { ideal: 640 }, height: { ideal: 480 } }, 
                    audio: false 
                }; 
                const newVideoStream = await navigator.mediaDevices.getUserMedia(newConstraints);
                const newVideoTrack = newVideoStream.getVideoTracks()[0];

                localStream.removeTrack(currentVideoTrack);
                localStream.addTrack(newVideoTrack);
                localVideo.srcObject = null; 
                localVideo.srcObject = localStream; 
                currentCameraDeviceId = newVideoTrack.getSettings().deviceId;

                const videoSender = peerConnection.getSenders().find(sender => sender.track && sender.track.kind === 'video');
                if (videoSender) {
                    await videoSender.replaceTrack(newVideoTrack);
                    console.log("Camera switched and track replaced in PeerConnection.");
                } else {
                    console.error("Could not find video sender to replace track.");
                }
                isVideoActive = true; 
                updateLocalTrackStatusUI();
                await updateLocalTrackStatus();

            } catch (error) {
                console.error("Error switching camera:", error);
                showErrorMessage("Failed to switch camera: " + error.message);
                await setupPeerConnection(currentCallType); 
            }
        };
        
        const toggleFullScreen = () => {
            if (!document.fullscreenElement) {
                videoCallArea.requestFullscreen().catch(err => {
                    showErrorMessage(`Error enabling full-screen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };
        
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                toggleFullscreenButton.innerHTML = '<i class="fas fa-expand"></i> <span class="hidden sm:inline">Full</span>';
            } else {
                toggleFullscreenButton.innerHTML = '<i class="fas fa-compress"></i> <span class="hidden sm:inline">Exit</span>';
            }
        });


        const toggleChatCallView = () => {
            const isChatVisible = !messageArea.classList.contains('hidden');
            if (isChatVisible) { 
                if (!peerConnection && !joinCallButton.classList.contains('hidden')) { 
                    // Show call view for joining
                } else if (!peerConnection) {
                    showErrorMessage("No active call to switch to. Start or join a call.");
                    return;
                }
                videoCallArea.classList.remove('hidden');
                messageArea.classList.add('hidden');
                toggleViewButton.innerHTML = '<i class="fas fa-comments"></i> <span class="hidden sm:inline">Chat</span>';
            } else { 
                videoCallArea.classList.add('hidden');
                messageArea.classList.remove('hidden');
                toggleViewButton.innerHTML = '<i class="fas fa-video"></i> <span class="hidden sm:inline">Call</span>';
            }
        };

        // Event Listeners Setup (remains unchanged from previous update)
        verifyKeyButton.addEventListener('click', () => { 
            deriveEncryptionKey(sharedSecretInput.value); 
            keyWarningDiv.classList.add('hidden'); 
        });
        gotItButton.addEventListener('click', () => keyWarningDiv.classList.add('hidden'));
        
        document.getElementById('messageForm').addEventListener('submit', async (e) => {
            e.preventDefault(); const messageText = messageInput.value.trim();
            if (!messageText || !db || !userId || !derivedKey || !callRoomId) { showErrorMessage("Enter secret & message, and ensure you are in a room."); return; }
            try {
                const { encryptedText, iv } = await encryptMessage(messageText);
                const messageData = { senderId: userId, encryptedText, iv, timestamp: serverTimestamp(), type: 'text', roomId: callRoomId }; 
                const path = getMessagesColPath();
                if (path) await addDoc(collection(db, path), messageData);
                else console.error("Cannot send message, path is null.");
                messageInput.value = ''; hideErrorMessage();
            } catch (error) { console.error("Send message error:", error); showErrorMessage("Failed to send message."); }
        });

        mediaInput.addEventListener('change', async (e) => {
            const file = e.target.files[0]; if (!file) return;
            if (!db || !userId || !derivedKey || !callRoomId) { showErrorMessage("Enter secret key for media and ensure you are in a room."); e.target.value = ''; return; }
            if (file.size > 5 * 1024 * 1024) { showErrorMessage("File > 5MB. Choose smaller."); e.target.value = ''; return; } 
            
            const uploadingMsg = showErrorMessage("Uploading & encrypting media..."); 
            
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const { encryptedText, iv } = await encryptMessage(event.target.result); 
                    const messageData = { senderId: userId, encryptedContent: encryptedText, iv, timestamp: serverTimestamp(), type: 'media', mediaType: file.type.split('/')[0], fileName: file.name, roomId: callRoomId }; 
                    const path = getMessagesColPath();
                    if (path) await addDoc(collection(db, path), messageData);
                    else console.error("Cannot send media, path is null.");
                    hideErrorMessage(); e.target.value = ''; 
                } catch (error) { console.error("Share media error:", error); showErrorMessage("Failed to share media. " + error.message); }
            };
            reader.onerror = () => {
                showErrorMessage("Error reading file for media sharing.");
                hideErrorMessage(); 
                e.target.value = '';
            };
            reader.readAsDataURL(file);
        });

        startAudioCallButton.addEventListener('click', () => startCall('audio'));
        startVideoCallButton.addEventListener('click', () => startCall('video'));
        joinCallButton.addEventListener('click', joinExistingCall);
        hangUpButton.addEventListener('click', () => endCall(true)); 
        
        toggleMicButton.addEventListener('click', toggleLocalMic);
        toggleVideoButton.addEventListener('click', toggleLocalVideo);
        switchCamButton.addEventListener('click', switchCamera);
        toggleFullscreenButton.addEventListener('click', toggleFullScreen);
        toggleViewButton.addEventListener('click', toggleChatCallView);
        
        window.addEventListener('beforeunload', () => { 
            stopPresenceUpdates(); 
        });

    </script>
</body>
</html>
